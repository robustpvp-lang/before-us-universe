<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SPACE COMBAT 9000</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /*
        * ------------------------------------
        * Global Styling
        * ------------------------------------
        */
        :root {
            --dos-green: #00ff00;
            --dos-dark: #000000;
            --text-color: #ffffff;
            --canvas-bg: #030712; /* Darker background */
            --ship-color: #3b82f6;
            --bullet-color: #fde047;
            --enemy-color: #ef4444;
            --canvas-width: 800px;
            --canvas-height: 600px;
        }

        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: #1f2937; /* Gray 800 */
            color: var(--text-color);
            font-family: 'Inter', monospace, sans-serif;
            margin: 0;
            padding: 10px;
            overflow-x: hidden;
        }

        #game-container {
            position: relative;
            width: 100%;
            max-width: var(--canvas-width);
            aspect-ratio: 4/3;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5);
            border: 4px solid var(--dos-green); /* DOS Border */
            border-radius: 6px;
        }

        canvas {
            background-color: var(--canvas-bg);
            display: block;
            width: 100%;
            height: 100%;
        }

        /*
        * ------------------------------------
        * DOS Title Screen Styling
        * ------------------------------------
        */
        #title-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--dos-dark);
            color: var(--dos-green);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            z-index: 100;
            font-family: monospace; /* For that blocky DOS look */
        }

        #title-screen h1 {
            font-size: clamp(1.5rem, 8vw, 3.5rem);
            margin-bottom: 1rem;
            text-shadow: 2px 2px #000;
            animation: blink-text 1s step-end infinite;
        }

        #title-screen p {
            font-size: clamp(0.75rem, 3vw, 1.25rem);
            margin-top: 2rem;
        }

        #start-button {
            padding: 0.5rem 1.5rem;
            margin-top: 1.5rem;
            background-color: var(--dos-green);
            color: var(--dos-dark);
            border: 2px solid var(--dos-green);
            font-family: monospace;
            cursor: pointer;
            box-shadow: 4px 4px 0px 0px var(--dos-green);
            transition: all 0.1s;
        }

        #start-button:hover {
            box-shadow: 2px 2px 0px 0px var(--dos-green);
            transform: translate(2px, 2px);
        }

        @keyframes blink-text {
            50% { opacity: 0.2; }
        }

        /*
        * ------------------------------------
        * Mobile Controls Styling
        * ------------------------------------
        */
        #controls {
            display: grid;
            grid-template-areas:
                "up up shoot"
                "left down right";
            gap: 10px;
            margin-top: 15px;
            padding: 10px;
            width: 100%;
            max-width: var(--canvas-width);
        }

        .ctrl-btn {
            background-color: #374151; /* Gray 700 */
            color: var(--text-color);
            border: 2px solid #9ca3af; /* Gray 400 */
            border-radius: 50%;
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            user-select: none;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            transition: background-color 0.1s, transform 0.1s;
        }

        .ctrl-btn:active {
            background-color: #4b5563; /* Gray 600 */
            transform: scale(0.95);
        }

        #ctrl-up { grid-area: up; border-radius: 10px; }
        #ctrl-down { grid-area: down; }
        #ctrl-left { grid-area: left; }
        #ctrl-right { grid-area: right; }
        #ctrl-shoot {
            grid-area: shoot;
            background-color: var(--enemy-color);
            border-color: #b91c1c;
            border-radius: 10px;
            width: 100%;
            height: 100%;
        }

        /* Hide controls on desktop, show on small screens */
        @media (min-width: 640px) {
            #controls { display: none; }
            body { padding: 0; }
        }

        @media (max-width: 640px) {
            .ctrl-btn {
                width: 70px;
                height: 70px;
            }
        }
    </style>
</head>
<body>

    <h1 class="text-xl font-bold mb-4">SPACE COMBAT 9000</h1>

    <div id="game-container">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <!-- DOS Style Title Screen -->
        <div id="title-screen" class="hidden">
            <pre class="text-xs mb-4">
88888888888888888888888888888888888888888888888888888888888888888888888888888888
8                                                                            8
8               ██████  ██████   █████  ██████  ███████ █████                8
8              ██      ██       ██   ██ ██   ██ ██      ██   ██              8
8              ██████  ██      ██     ██ ██████  █████  ██████               8
8              ██      ██       ██   ██ ██   ██ ██      ██   ██              8
8               ██████  ██████   █████  ██████  ███████ ██   ██              8
8                                                                            8
8                          A 1990's TEXT-MODE CLASSIC                          8
8                          INITIATE DESTRUCTION PROTOCOL                       8
8                                                                            8
88888888888888888888888888888888888888888888888888888888888888888888888888888888
            </pre>
            <h1>SPACE COMBAT 9000</h1>
            <p>DESTROY THE ALIEN SWARM</p>
            <button id="start-button">PRESS START TO BEGIN</button>
            <p class="mt-8 text-sm">Use WASD/Arrow Keys to Move, Spacebar to Shoot</p>
        </div>
        <div id="game-over-screen" class="hidden absolute top-0 left-0 w-full h-full bg-black bg-opacity-80 flex flex-col items-center justify-center z-50 rounded-md">
            <h2 class="text-4xl font-mono text-red-500 mb-4">-- GAME OVER --</h2>
            <p class="text-xl font-mono text-white mb-6">Final Score: <span id="final-score">0</span></p>
            <button id="restart-button" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md shadow-lg transition duration-150">RESTART GAME</button>
        </div>
    </div>

    <!-- Mobile Controls -->
    <div id="controls">
        <button id="ctrl-up" class="ctrl-btn" ontouchstart="setMovement('up', true)" ontouchend="setMovement('up', false)">&#9650;</button>
        <button id="ctrl-left" class="ctrl-btn" ontouchstart="setMovement('left', true)" ontouchend="setMovement('left', false)">&#9664;</button>
        <button id="ctrl-down" class="ctrl-btn" ontouchstart="setMovement('down', true)" ontouchend="setMovement('down', false)">&#9660;</button>
        <button id="ctrl-right" class="ctrl-btn" ontouchstart="setMovement('right', true)" ontouchend="setMovement('right', false)">&#9654;</button>
        <button id="ctrl-shoot" class="ctrl-btn" ontouchstart="setMovement('shoot', true)" ontouchend="setMovement('shoot', false)">FIRE</button>
    </div>

    <script>
        // Set up the canvas and context
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('game-container');
        const titleScreen = document.getElementById('title-screen');
        const startButton = document.getElementById('start-button');
        const gameOverScreen = document.getElementById('game-over-screen');
        const restartButton = document.getElementById('restart-button');
        const finalScoreDisplay = document.getElementById('final-score');

        // Game Constants
        const PLAYER_SPEED = 5;
        const BULLET_SPEED = 7;
        const ENEMY_SPEED = 2;

        // Global Game State
        let gameRunning = false;
        let score = 0;
        let lastSpawnTime = 0;
        let enemies = [];
        let playerBullets = [];
        let enemyBullets = [];
        let drones = []; // For Carrier-spawned drones
        let level = 1;

        // --- SPAWN RATE LOGIC ---
        const BASE_SPAWN_DELAY = 2000; // milliseconds
        let currentSpawnDelay = BASE_SPAWN_DELAY;

        // Player Object
        const player = {
            x: canvas.width / 2,
            y: canvas.height - 50,
            width: 40,
            height: 20,
            color: 'var(--ship-color)',
            health: 3,
            shooting: false,
            canShoot: true,
            shootDelay: 200, // ms
            lastShotTime: 0,
            movingLeft: false,
            movingRight: false,
            movingUp: false,
            movingDown: false,
        };

        // --- CORE CLASSES ---

        class Bullet {
            constructor(x, y, vx, vy, color = 'var(--bullet-color)', damage = 1) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.radius = 3;
                this.color = color;
                this.damage = damage;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.closePath();
            }
        }

        class Enemy {
            constructor(x, y, type, health, color, width, height, shootInterval = 1000) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.health = health;
                this.maxHealth = health;
                this.color = color;
                this.width = width;
                this.height = height;
                this.vx = ENEMY_SPEED;
                this.vy = 0;
                this.shootInterval = shootInterval;
                this.lastShotTime = Date.now();
            }

            draw() {
                // Draw a simple box (replace with more detailed shapes if desired)
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);

                // Draw Health Bar
                const healthRatio = this.health / this.maxHealth;
                const healthBarWidth = this.width;
                const healthBarHeight = 3;
                ctx.fillStyle = '#333';
                ctx.fillRect(this.x, this.y - 8, healthBarWidth, healthBarHeight);
                ctx.fillStyle = healthRatio > 0.5 ? '#0f0' : healthRatio > 0.2 ? '#ff0' : '#f00';
                ctx.fillRect(this.x, this.y - 8, healthBarWidth * healthRatio, healthBarHeight);
            }

            update() {
                this.x += this.vx;

                // Bounce off walls
                if (this.x + this.width > canvas.width || this.x < 0) {
                    this.vx *= -1;
                    this.y += 20; // Move down a row
                }

                // Brute specific attack logic
                if (this.type === 'Brute' && Date.now() - this.lastShotTime > this.shootInterval) {
                    this.shootBrute();
                    this.lastShotTime = Date.now();
                }

                // Carrier specific attack logic
                if (this.type === 'Carrier' && Date.now() - this.lastShotTime > this.shootInterval * 1.5) {
                    this.spawnDrones();
                    this.lastShotTime = Date.now();
                }

                // Drone specific movement
                if (this.type === 'Drone') {
                    // Drones track the player
                    const dx = player.x - this.x;
                    const dy = player.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    this.x += (dx / dist) * ENEMY_SPEED * 0.8;
                    this.y += (dy / dist) * ENEMY_SPEED * 0.8;
                }
            }
            
            // --- UPDATED BRUTE ATTACK (Increased bullets by 2) ---
            shootBrute() {
                // Brute fires a spread of 5 bullets (original 3 + 2 more)
                const bulletCount = 5;
                const angleStep = Math.PI / (bulletCount + 1);
                
                for (let i = 1; i <= bulletCount; i++) {
                    // Start angle from Math.PI (downwards)
                    const angle = Math.PI - (Math.PI / 3) + (i * angleStep * 0.6); // Narrowing the spread slightly
                    const vx = Math.sin(angle) * BULLET_SPEED * 0.7;
                    const vy = Math.cos(angle) * BULLET_SPEED * 0.7;
                    enemyBullets.push(new Bullet(
                        this.x + this.width / 2,
                        this.y + this.height,
                        vx,
                        vy,
                        '#ff00ff' // Purple bullets
                    ));
                }
            }

            // --- UPDATED CARRIER ATTACK (Increased drones by 2) ---
            spawnDrones() {
                // Carrier spawns 4 drones (original 2 + 2 more)
                const droneCount = 4;
                const offsets = [
                    {x: -this.width/2, y: this.height + 5},
                    {x: this.width*1.5, y: this.height + 5},
                    // The two new offsets:
                    {x: 0, y: this.height * 2},
                    {x: this.width, y: this.height * 2}
                ];

                for (let i = 0; i < droneCount; i++) {
                    if (offsets[i]) {
                         // Drones are smaller, lower health, and the 'Drone' type
                         drones.push(new Enemy(
                            this.x + offsets[i].x,
                            this.y + offsets[i].y,
                            'Drone',
                            1,
                            '#4ade80', // Green Drone
                            15, 15,
                            1000 // Drones shoot too, but rarely
                        ));
                    }
                }
            }
        }

        // --- GAME LOGIC FUNCTIONS ---

        function initGame() {
            // Reset state
            score = 0;
            level = 1;
            enemies = [];
            playerBullets = [];
            enemyBullets = [];
            drones = [];
            currentSpawnDelay = BASE_SPAWN_DELAY;

            player.health = 3;
            player.x = canvas.width / 2;
            player.y = canvas.height - 50;
        }

        function checkLevelClear() {
            // Check if both main enemies and drones are cleared
            if (enemies.length === 0 && drones.length === 0 && gameRunning) {
                // Level cleared!
                levelUp();
            }
        }

        // --- LEVEL UP LOGIC (Increased spawn rate) ---
        function levelUp() {
            level++;
            // Increase spawn rate by reducing delay. This makes spawning 10% faster per level.
            currentSpawnDelay = BASE_SPAWN_DELAY * Math.pow(0.9, level - 1);
            if (currentSpawnDelay < 500) currentSpawnDelay = 500; // Cap delay at 0.5s

            showMessage(`LEVEL ${level} INCOMING! Spawn Rate Increased!`, 1500, 'var(--dos-green)');
            setTimeout(spawnInitialEnemies, 1500); // Start new wave after message
        }


        function spawnEnemy(type) {
            const x = Math.random() * (canvas.width - 60);
            let enemy;

            switch (type) {
                case 'Basic':
                    enemy = new Enemy(x, 20, 'Basic', 2, 'var(--enemy-color)', 40, 20);
                    break;
                case 'Brute':
                    // Brutes are tougher and shoot
                    enemy = new Enemy(x, 20, 'Brute', 5 + level, '#ff6600', 60, 30, 1500 - (level * 50));
                    break;
                case 'Carrier':
                    // Carriers are even tougher and spawn drones
                    enemy = new Enemy(x, 20, 'Carrier', 8 + level * 2, '#8000ff', 80, 40, 3000 - (level * 100));
                    break;
            }

            if (enemy) enemies.push(enemy);
        }

        function spawnInitialEnemies() {
            // Basic wave generation for the start of a level
            for (let i = 0; i < 5 + level; i++) {
                spawnEnemy('Basic');
            }
            if (level >= 2) spawnEnemy('Brute');
            if (level >= 3) spawnEnemy('Carrier');
            if (level >= 5) spawnEnemy(Math.random() > 0.5 ? 'Brute' : 'Carrier');
        }

        function handleSpawning(timestamp) {
            if (timestamp - lastSpawnTime > currentSpawnDelay) {
                const rand = Math.random();
                if (rand < 0.6) {
                    spawnEnemy('Basic');
                } else if (rand < 0.8) {
                    spawnEnemy('Brute');
                } else {
                    spawnEnemy('Carrier');
                }
                lastSpawnTime = timestamp;
            }
        }

        function drawPlayer() {
            ctx.fillStyle = player.color;
            ctx.fillRect(player.x - player.width / 2, player.y - player.height / 2, player.width, player.height);

            // Draw Health
            ctx.fillStyle = 'white';
            ctx.font = '12px monospace';
            ctx.fillText(`HP: ${player.health}`, player.x - 10, player.y + 25);
        }

        function updatePlayer() {
            if (player.movingLeft) player.x -= PLAYER_SPEED;
            if (player.movingRight) player.x += PLAYER_SPEED;
            if (player.movingUp) player.y -= PLAYER_SPEED;
            if (player.movingDown) player.y += PLAYER_SPEED;

            // Keep player within bounds
            player.x = Math.max(player.width / 2, Math.min(canvas.width - player.width / 2, player.x));
            player.y = Math.max(player.height / 2, Math.min(canvas.height - player.height / 2, player.y));

            if (player.shooting) handlePlayerShoot();
        }

        function handlePlayerShoot() {
            const now = Date.now();
            if (player.canShoot && now - player.lastShotTime > player.shootDelay) {
                // Fire a single bullet
                playerBullets.push(new Bullet(player.x, player.y - player.height / 2, 0, -BULLET_SPEED));
                player.lastShotTime = now;
            }
        }

        function updateGame() {
            if (!gameRunning) return;

            updatePlayer();

            // Update Bullets
            playerBullets.forEach(b => b.update());
            enemyBullets.forEach(b => b.update());

            // Filter out-of-bounds bullets
            playerBullets = playerBullets.filter(b => b.y > 0);
            enemyBullets = enemyBullets.filter(b => b.y < canvas.height);

            // Update Enemies
            enemies.forEach(e => e.update());
            drones.forEach(d => d.update());

            handleCollisions();
            checkLevelClear();

            // Filter dead entities
            enemies = enemies.filter(e => e.health > 0);
            drones = drones.filter(d => d.health > 0);

            // Check Game Over
            if (player.health <= 0) {
                gameOver();
            }
        }

        function handleCollisions() {
            // Player Bullet vs. Enemies
            playerBullets.forEach((bullet, bIndex) => {
                // Check main enemies
                enemies.forEach((enemy, eIndex) => {
                    if (checkCollision(bullet, enemy)) {
                        enemy.health -= bullet.damage;
                        playerBullets.splice(bIndex, 1);
                        score += 10;
                        if (enemy.health <= 0) {
                            score += enemy.maxHealth * 5; // Bonus for destroying tough enemies
                        }
                    }
                });
                // Check drones
                drones.forEach((drone, dIndex) => {
                    if (checkCollision(bullet, drone)) {
                        drone.health -= bullet.damage;
                        playerBullets.splice(bIndex, 1);
                        score += 5;
                        if (drone.health <= 0) {
                            score += 15;
                        }
                    }
                });
            });

            // Enemy Bullet vs. Player
            enemyBullets.forEach((bullet, bIndex) => {
                if (checkCollision(bullet, player)) {
                    player.health -= bullet.damage;
                    enemyBullets.splice(bIndex, 1);
                }
            });

            // Enemy/Drone vs. Player (Ramming)
            [...enemies, ...drones].forEach((enemy) => {
                if (checkCollision(player, enemy)) {
                    player.health -= 1; // Take ramming damage
                    enemy.health = 0; // Enemy is also destroyed
                }
            });
        }

        function checkCollision(objA, objB) {
            // Player/Enemy Collision (AABB)
            if (objA.width && objB.width) {
                return objA.x < objB.x + objB.width &&
                       objA.x + objA.width > objB.x &&
                       objA.y < objB.y + objB.height &&
                       objA.y + objA.height > objB.y;
            }
            // Bullet vs. Object Collision (Circle vs. AABB)
            const closestX = Math.max(objB.x, Math.min(objA.x, objB.x + objB.width));
            const closestY = Math.max(objB.y, Math.min(objA.y, objB.y + objB.height));
            const distX = objA.x - closestX;
            const distY = objA.y - closestY;
            return (distX * distX + distY * distY) < (objA.radius * objA.radius);
        }

        let messageTimeout;
        function showMessage(text, duration, color = 'white') {
            // Clear any previous message timeout
            if (messageTimeout) {
                clearTimeout(messageTimeout);
            }

            // Draw text directly to the canvas
            ctx.save();
            ctx.font = 'bold 30px monospace';
            ctx.fillStyle = color;
            ctx.textAlign = 'center';
            ctx.fillText(text, canvas.width / 2, canvas.height / 2);
            ctx.restore();

            // Schedule removal
            messageTimeout = setTimeout(() => {
                messageTimeout = null;
            }, duration);
        }

        function drawScore() {
            ctx.fillStyle = 'var(--dos-green)';
            ctx.font = '18px monospace';
            ctx.fillText(`SCORE: ${score}`, 10, 25);
            ctx.fillText(`LEVEL: ${level}`, canvas.width - 100, 25);
        }

        // --- GAME LOOP ---
        function gameLoop(timestamp) {
            // Clear the canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (gameRunning) {
                handleSpawning(timestamp);
                updateGame();

                drawPlayer();
                playerBullets.forEach(b => b.draw());
                enemyBullets.forEach(b => b.draw());
                enemies.forEach(e => e.draw());
                drones.forEach(d => d.draw());

                drawScore();

                // If a message is active, redraw it over everything
                if (messageTimeout) {
                    ctx.save();
                    ctx.font = 'bold 30px monospace';
                    ctx.fillStyle = 'var(--dos-green)';
                    ctx.textAlign = 'center';
                    ctx.fillText(ctx.messageText, canvas.width / 2, canvas.height / 2);
                    ctx.restore();
                }

                requestAnimationFrame(gameLoop);
            } else {
                // If game stopped and not showing Game Over, show title screen
                if (gameOverScreen.classList.contains('hidden')) {
                     showTitleScreen();
                }
            }
        }

        function startGame() {
            titleScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            gameRunning = true;
            initGame();
            spawnInitialEnemies();
            requestAnimationFrame(gameLoop);
        }

        function gameOver() {
            gameRunning = false;
            finalScoreDisplay.textContent = score;
            gameOverScreen.classList.remove('hidden');
        }

        function showTitleScreen() {
            titleScreen.classList.remove('hidden');
        }

        // --- INPUT HANDLING ---

        function setMovement(direction, isMoving) {
            switch (direction) {
                case 'up':
                    player.movingUp = isMoving;
                    break;
                case 'down':
                    player.movingDown = isMoving;
                    break;
                case 'left':
                    player.movingLeft = isMoving;
                    break;
                case 'right':
                    player.movingRight = isMoving;
                    break;
                case 'shoot':
                    player.shooting = isMoving;
                    break;
            }
        }

        // Keyboard Event Listeners (for desktop/keyboard play)
        document.addEventListener('keydown', (e) => {
            if (!gameRunning) return;
            switch (e.key) {
                case 'a':
                case 'A':
                case 'ArrowLeft':
                    setMovement('left', true);
                    break;
                case 'd':
                case 'D':
                case 'ArrowRight':
                    setMovement('right', true);
                    break;
                case 'w':
                case 'W':
                case 'ArrowUp':
                    setMovement('up', true);
                    break;
                case 's':
                case 'S':
                case 'ArrowDown':
                    setMovement('down', true);
                    break;
                case ' ': // Spacebar
                    setMovement('shoot', true);
                    e.preventDefault(); // Prevent scrolling
                    break;
            }
        });

        document.addEventListener('keyup', (e) => {
            if (!gameRunning) return;
            switch (e.key) {
                case 'a':
                case 'A':
                case 'ArrowLeft':
                    setMovement('left', false);
                    break;
                case 'd':
                case 'D':
                case 'ArrowRight':
                    setMovement('right', false);
                    break;
                case 'w':
                case 'W':
                case 'ArrowUp':
                    setMovement('up', false);
                    break;
                case 's':
                case 'S':
                case 'ArrowDown':
                    setMovement('down', false);
                    break;
                case ' ': // Spacebar
                    setMovement('shoot', false);
                    break;
            }
        });

        // Button Event Listeners (Title/Game Over Screens)
        startButton.addEventListener('click', startGame);
        restartButton.addEventListener('click', startGame);

        // Mobile touch event listeners are bound inline in the HTML: ontouchstart/ontouchend
        // e.g., ontouchstart="setMovement('up', true)"

        // Start the game by showing the Title Screen
        window.onload = () => {
             // Adapt canvas size to container for responsiveness
            const resizeCanvas = () => {
                const rect = gameContainer.getBoundingClientRect();
                canvas.width = rect.width;
                canvas.height = rect.height;
                // Re-center player on resize if the game is running
                if (gameRunning) {
                    player.x = canvas.width / 2;
                    player.y = canvas.height - 50;
                }
            };

            // Initial sizing and listener setup
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            // Hide the game over screen initially
            gameOverScreen.classList.add('hidden');

            showTitleScreen();
        };

    </script>
</body>
</html>
