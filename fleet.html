<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Fleet Command: Invaders</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      /* Prevents iOS/Android from showing menus on long press */
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }
    body {
      overflow: hidden;
      background: #000;
      font-family: 'Courier New', monospace;
      /* Allow horizontal scrolling to prevent mobile issues, but hide overflow */
      touch-action: pan-y;
    }
    #gameCanvas {
      display: block;
      background: #000;
      touch-action: none; /* Critical for preventing zoom/scroll on game area */
    }
    #startScreen, #gameOverScreen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      color: #0f0;
      text-align: center;
    }
    /* Enhanced Title Screen Styling */
    #startScreen h1 {
      font-size: 56px;
      margin-bottom: 20px;
      color: #ff00ff; /* Bright magenta/pink */
      text-shadow: 0 0 15px #ff00ff, 0 0 5px #0f0;
      letter-spacing: 5px;
      animation: blink 1s step-end infinite;
    }
    @keyframes blink { 50% { opacity: 0.8; } }
    #startScreen h2 {
      font-size: 24px;
      color: #00ffff;
      margin-bottom: 10px;
      text-shadow: 0 0 5px #00ffff;
    }
    #startScreen p {
      margin-bottom: 30px;
      font-size: 14px;
      color: #0f0;
    }
    #gameOverScreen h1 {
      color: #f00;
      font-size: 48px;
      text-shadow: 0 0 15px #f00;
      margin-bottom: 20px;
    }
    #finalScore {
      font-size: 24px;
      margin-bottom: 30px;
      color: #0f0;
    }
    .mode-btn {
      background: rgba(0, 255, 0, 0.2);
      border: 2px solid #0f0;
      color: #0f0;
      padding: 15px 30px;
      margin: 10px;
      cursor: pointer;
      font-family: 'Courier New', monospace;
      font-size: 16px;
      font-weight: bold;
      text-transform: uppercase;
      box-shadow: 0 0 5px #0f0;
      transition: all 0.1s;
    }
    .mode-btn:hover {
      background: rgba(0, 255, 0, 0.4);
      box-shadow: 0 0 10px #0f0;
    }
    #hud {
      position: absolute;
      top: 10px;
      left: 10px;
      color: #0f0;
      font-size: 12px;
      text-shadow: 0 0 5px #0f0;
      pointer-events: none;
      z-index: 10;
    }
    #minimap {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      width: 100px;
      height: 100px;
      border: 2px solid #0f0;
      background: rgba(0, 0, 0, 0.7);
      z-index: 10;
    }
    .ship-select {
      position: absolute;
      top: 10px;
      right: 10px;
      display: flex;
      flex-direction: column;
      gap: 5px;
      z-index: 10;
    }
    .ship-btn {
      background: rgba(0, 255, 0, 0.2);
      border: 1px solid #0f0;
      color: #0f0;
      padding: 8px 12px;
      cursor: pointer;
      font-family: 'Courier New', monospace;
      font-size: 11px;
      touch-action: manipulation;
    }
    .ship-btn.active {
      background: rgba(0, 255, 0, 0.6);
    }
    #joystick {
      position: absolute;
      bottom: 20px;
      left: 20px;
      width: 120px;
      height: 120px;
      background: rgba(0, 255, 0, 0.1);
      border: 2px solid rgba(0, 255, 0, 0.3);
      border-radius: 50%;
      z-index: 10;
      display: none;
      touch-action: none; /* Important for preventing touch conflicts */
    }
    #joystick-knob {
      position: absolute;
      width: 50px;
      height: 50px;
      background: rgba(0, 255, 0, 0.5);
      border: 2px solid #0f0;
      border-radius: 50%;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
    #fireBtn {
      position: absolute;
      bottom: 20px;
      right: 5px;
      width: 80px;
      height: 80px;
      background: rgba(255, 0, 0, 0.3);
      border: 2px solid #f00;
      border-radius: 50%;
      color: #f00;
      font-size: 12px;
      font-weight: bold;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 10;
      touch-action: manipulation;
    }
    #fireBtn.active {
      background: rgba(255, 0, 0, 0.6);
    }
    #controls {
      position: absolute;
      bottom: 10px;
      left: 10px;
      color: #0f0;
      font-size: 11px;
      text-shadow: 0 0 5px #0f0;
      display: none;
    }
  </style>
</head>
<body>
  <div id="startScreen">
    <h1>FLEET COMMAND: INVADERS</h1>
    <h2>A Deep-Space Retro Arcade Experience</h2>
    <p style="font-size: 14px; margin-bottom: 30px; color: #00ffff; text-shadow: 0 0 5px #00ffff;">
      Protocol Coded by **Patrick McDonald** and a **Legion of AI**
    </p>
    <p>INITIATE GAME MODE</p>
    <button class="mode-btn" onclick="startGame('mobile')">MOBILE (Touch/Joystick)</button>
    <button class="mode-btn" onclick="startGame('desktop')">DESKTOP (Keyboard)</button>
  </div>

  <div id="gameOverScreen" style="display: none;">
    <h1>SHIP DESTROYED!</h1>
    <div id="finalScore">FINAL SCORE: 0</div>
    <button class="mode-btn" onclick="window.location.reload()">RE-INITIALIZE PROTOCOL</sbutton>
  </div>

  <canvas id="gameCanvas"></canvas>
  <canvas id="minimap"></canvas>
  
  <div id="hud">
    <div>SCORE: <span id="score">0</span></div>
    <div>SHIP: <span id="shipType">FIGHTER</span></div>
    <div>HULL: <span id="health">100</span>%</div>
  </div>
  
  <div class="ship-select">
    <button class="ship-btn active" data-ship="fighter">FIGHTER</button>
    <button class="ship-btn" data-ship="carrier">CARRIER</button>
    <button class="ship-btn" data-ship="brute">BRUTE</button>
  </div>

  <div id="joystick">
    <div id="joystick-knob"></div>
  </div>
  
  <button id="fireBtn">FIRE</button>
  
  <div id="controls">WASD: Move | **L**: Fire (Fighter/Brute) or Boost (Carrier) | 1/2/3: Switch Ship</div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const minimap = document.getElementById('minimap');
    const minimapCtx = minimap.getContext('2d');
    
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const WORLD_SIZE = 2000;
    const INVADER_COUNT = 80;
    const NUM_STARS = 150; // Constant star count for performance

    let score = 0;
    let gameTime = 0;
    let joystickActive = false;
    let joystickDir = {x: 0, y: 0};
    let firing = false;
    let controlMode = null;
    let keys = {};
    let invaders = [];
    let invaderBullets = [];
    let ship = null;
    let gameStarted = false;
    let gameOver = false;
    // Initialize stars once for performance
    const stars = [];
    for (let i = 0; i < NUM_STARS; i++) {
      stars.push({
        x: Math.random() * WORLD_SIZE,
        y: Math.random() * WORLD_SIZE,
        size: Math.random() * 2 + 0.5
      });
    }

    class Vector {
      constructor(x, y) {
        this.x = x;
        this.y = y;
      }
      add(v) { return new Vector(this.x + v.x, this.y + v.y); }
      mult(s) { return new Vector(this.x * s, this.y * s); }
      mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
      normalize() { const m = this.mag(); return m > 0 ? this.mult(1/m) : new Vector(0, 0); }
    }

    class Ship {
      constructor(x, y, type) {
        this.pos = new Vector(x, y);
        this.vel = new Vector(0, 0);
        this.angle = 0;
        this.type = type;
        this.bullets = [];
        this.drones = [];
        
        if (type === 'fighter') {
          this.maxSpeed = 6;
          this.accel = 0.25;
          this.health = 100;
          this.maxHealth = 100;
          this.fireRate = 5;
          this.size = 12;
          this.hitRadius = 10;
        } else if (type === 'carrier') {
          this.maxSpeed = 3;
          this.accel = 0.12;
          this.health = 250;
          this.maxHealth = 250;
          this.fireRate = 320;
          this.size = 20;
          this.hitRadius = 18;
          this.boostPower = 0.5;
          this.maxBoostSpeed = 7;
        } else if (type === 'brute') {
          this.maxSpeed = 5;
          this.accel = 0.2;
          this.health = 150;
          this.maxHealth = 150;
          this.fireRate = 53;
          this.size = 14;
          this.hitRadius = 12;
        }
        
        this.lastFire = 0;
      }

      update() {
        if (controlMode === 'mobile') {
          if (joystickDir.x !== 0 || joystickDir.y !== 0) {
            const dir = new Vector(joystickDir.x, joystickDir.y).normalize();
            this.angle = Math.atan2(dir.y, dir.x);
            this.vel = this.vel.add(dir.mult(this.accel));
          }
        } else {
          const dir = new Vector(0, 0);
          if (keys['w'] || keys['W']) dir.y -= 1;
          if (keys['s'] || keys['S']) dir.y += 1;
          if (keys['a'] || keys['A']) dir.x -= 1;
          if (keys['d'] || keys['D']) dir.x += 1;

          if (dir.mag() > 0) {
            this.angle = Math.atan2(dir.y, dir.x);
            const force = dir.normalize().mult(this.accel);
            this.vel = this.vel.add(force);
          }
        }

        // Check for 'l' key for desktop firing/boosting
        const desktopAction = keys['l'] || keys['L'];

        // Boost for carrier (desktop/mobile)
        if (this.type === 'carrier' && (desktopAction || (controlMode === 'mobile' && firing))) {
          const boostDir = new Vector(Math.cos(this.angle), Math.sin(this.angle));
          this.vel = this.vel.add(boostDir.mult(this.boostPower));
          
          if (this.vel.mag() > this.maxBoostSpeed) {
            this.vel = this.vel.normalize().mult(this.maxBoostSpeed);
          }
        } else {
          // Normal speed limit
          if (this.vel.mag() > this.maxSpeed) {
            this.vel = this.vel.normalize().mult(this.maxSpeed);
          }
        }

        this.vel = this.vel.mult(0.97);
        this.pos = this.pos.add(this.vel);

        // Wrap around world limits
        if (this.pos.x < 0) this.pos.x = WORLD_SIZE;
        if (this.pos.x > WORLD_SIZE) this.pos.x = 0;
        if (this.pos.y < 0) this.pos.y = WORLD_SIZE;
        if (this.pos.y > WORLD_SIZE) this.pos.y = 0;

        // Fire logic (Desktop or Mobile manual fire)
        const shouldFire = (controlMode === 'desktop' && this.type !== 'carrier' && desktopAction) ||
                         (controlMode === 'mobile' && this.type !== 'carrier' && firing);
        
        if (shouldFire && gameTime - this.lastFire > this.fireRate) {
          this.fire();
          this.lastFire = gameTime;
        }

        this.bullets = this.bullets.filter(b => {
          b.update();
          return b.life > 0;
        });

        this.drones = this.drones.filter(d => {
          d.update(this.pos);
          return d.life > 0;
        });

        if (this.type === 'carrier' && this.drones.length < 3 && gameTime % 150 === 0) {
          this.drones.push(new Drone(this.pos.x, this.pos.y));
        }

        if (this.health <= 0) {
          triggerGameOver();
        }
      }

      fire() {
        const speed = 12;
        const shipVel = this.vel;
        
        if (this.type === 'fighter') {
          const vx = Math.cos(this.angle) * speed + shipVel.x;
          const vy = Math.sin(this.angle) * speed + shipVel.y;
          // Fighter bullet life reduced from 100 to 66 (approx 1/3 reduction in range)
          this.bullets.push(new Bullet(this.pos.x, this.pos.y, vx, vy, '#00ff00', 66)); 
        } else if (this.type === 'brute') {
          for (let i = -2; i <= 2; i++) {
            const angle = this.angle + i * 0.2;
            const vx = Math.cos(angle) * speed + shipVel.x;
            const vy = Math.sin(angle) * speed + shipVel.y;
            this.bullets.push(new Bullet(this.pos.x, this.pos.y, vx, vy, '#ff4400', 100));
          }
        }
      }

      draw(offsetX, offsetY) {
        ctx.save();
        ctx.translate(this.pos.x - offsetX, this.pos.y - offsetY);
        ctx.rotate(this.angle);
        
        if (this.type === 'fighter') {
          ctx.fillStyle = '#00ff00';
          ctx.beginPath();
          ctx.moveTo(this.size, 0);
          ctx.lineTo(-this.size, this.size/2);
          ctx.lineTo(-this.size/2, 0);
          ctx.lineTo(-this.size, -this.size/2);
          ctx.closePath();
          ctx.fill();
        } 
        else if (this.type === 'carrier') {
          const s = this.size;
          // Main Body (Long, flat diamond/kite shape)
          ctx.fillStyle = '#0088ff';
          ctx.beginPath();
          ctx.moveTo(s * 2, 0); // Front point
          ctx.lineTo(s * 0.5, s); // Mid-right
          ctx.lineTo(-s * 2, s * 0.5); // Rear-right
          ctx.lineTo(-s * 2, -s * 0.5); // Rear-left
          ctx.lineTo(s * 0.5, -s); // Mid-left
          ctx.closePath();
          ctx.fill();
          
          // Command Bridge (Top rear)
          ctx.fillStyle = '#00ffff';
          ctx.fillRect(-s * 0.5, -s * 0.25, s * 1.5, s * 0.5);
          
          // Engine Thrusters (Rear glow)
          ctx.fillStyle = '#ff9900';
          ctx.fillRect(-s * 2.5, -s * 0.2, s * 0.5, s * 0.4);

          // Add boost trail if boosting
          if ((controlMode === 'desktop' && (keys['l'] || keys['L'])) || (controlMode === 'mobile' && firing)) {
            ctx.fillStyle = 'rgba(255, 100, 0, 0.5)';
            ctx.beginPath();
            ctx.moveTo(-s * 2.5, 0);
            ctx.lineTo(-s * 3 - Math.random() * 10, s * 0.5);
            ctx.lineTo(-s * 3 - Math.random() * 10, -s * 0.5);
            ctx.closePath();
            ctx.fill();
          }
        } 
        else if (this.type === 'brute') {
          ctx.fillStyle = '#ff4400';
          ctx.beginPath();
          ctx.moveTo(this.size, 0);
          ctx.lineTo(-this.size, this.size);
          ctx.lineTo(-this.size, -this.size);
          ctx.closePath();
          ctx.fill();
          ctx.fillStyle = '#ff6622';
          ctx.fillRect(-this.size * 0.7, -this.size * 0.5, this.size * 1.4, this.size);
        }
        
        ctx.restore();

        this.bullets.forEach(b => b.draw(offsetX, offsetY));
        this.drones.forEach(d => d.draw(offsetX, offsetY));
      }
    }

    class Bullet {
      // Added defaultLife parameter
      constructor(x, y, vx, vy, color = '#ffff00', defaultLife = 100) {
        this.pos = new Vector(x, y);
        this.vel = new Vector(vx, vy);
        this.life = defaultLife; // Set life based on caller (Ship type)
        this.color = color;
        this.radius = 3;
      }

      update() {
        this.pos = this.pos.add(this.vel);
        this.life--;
      }

      draw(offsetX, offsetY) {
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.pos.x - offsetX, this.pos.y - offsetY, this.radius, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    class InvaderBullet extends Bullet {
      constructor(x, y, vx, vy) {
        super(x, y, vx, vy, '#ff00ff', 100);
        this.radius = 4;
        this.damage = 5;
      }
    }

    class Drone {
      constructor(x, y) {
        this.pos = new Vector(x, y);
        this.vel = new Vector(0, 0);
        this.life = 400;
        this.orbitAngle = Math.random() * Math.PI * 2;
        this.bullets = [];
        this.lastFire = 0;
        this.radius = 6;
      }

      update(parentPos) {
        this.orbitAngle += 0.04;
        const targetX = parentPos.x + Math.cos(this.orbitAngle) * 50;
        const targetY = parentPos.y + Math.sin(this.orbitAngle) * 50;
        
        this.vel.x += (targetX - this.pos.x) * 0.02;
        this.vel.y += (targetY - this.pos.y) * 0.02;
        this.vel = this.vel.mult(0.88);
        this.pos = this.pos.add(this.vel);
        this.life--;

        // Auto-fire at invaders
        if (gameTime - this.lastFire > 50) {
          const nearest = this.findNearestInvader();
          if (nearest && nearest.dist < 300) {
            this.fireAt(nearest.invader);
            this.lastFire = gameTime;
          }
        }

        this.bullets = this.bullets.filter(b => {
          b.update();
          return b.life > 0;
        });
      }

      findNearestInvader() {
        let nearest = null;
        let minDist = Infinity;
        invaders.forEach(inv => {
          const dx = inv.pos.x - this.pos.x;
          const dy = inv.pos.y - this.pos.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < minDist) {
            minDist = dist;
            nearest = { invader: inv, dist: dist };
          }
        });
        return nearest;
      }

      fireAt(invader) {
        const dx = invader.pos.x - this.pos.x;
        const dy = invader.pos.y - this.pos.y;
        const angle = Math.atan2(dy, dx);
        const speed = 9;
        const vx = Math.cos(angle) * speed;
        const vy = Math.sin(angle) * speed;
        this.bullets.push(new Bullet(this.pos.x, this.pos.y, vx, vy, '#00ffff', 100));
      }

      draw(offsetX, offsetY) {
        const x = this.pos.x - offsetX;
        const y = this.pos.y - offsetY;
        ctx.fillStyle = '#00ffff';
        ctx.strokeStyle = '#00ffff';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(x, y, this.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();

        this.bullets.forEach(b => b.draw(offsetX, offsetY));
      }
    }

    class Invader {
      constructor(x, y, size) {
        this.pos = new Vector(x, y);
        this.vel = new Vector((Math.random() - 0.5) * 1.5, (Math.random() - 0.5) * 1.5);
        this.size = size;
        this.angle = Math.random() * Math.PI * 2;
        this.rotSpeed = (Math.random() - 0.5) * 0.08;
        this.color = '#ff00ff';
        
        this.fireRate = 300 + Math.random() * 100; 
        this.lastFire = gameTime + Math.random() * this.fireRate;
      }

      update() {
        this.pos = this.pos.add(this.vel);
        this.angle += this.rotSpeed;

        // Wrap around world limits
        if (this.pos.x < 0) this.pos.x = WORLD_SIZE;
        if (this.pos.x > WORLD_SIZE) this.pos.x = 0;
        if (this.pos.y < 0) this.pos.y = WORLD_SIZE;
        if (this.pos.y > WORLD_SIZE) this.pos.y = 0;

        // Firing logic
        if (gameTime - this.lastFire > this.fireRate) {
          this.fire();
          this.lastFire = gameTime;
        }
      }

      fire() {
        const dx = ship.pos.x - this.pos.x;
        const dy = ship.pos.y - this.pos.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < 800) {
          const angle = Math.atan2(dy, dx);
          const speed = 7;
          const vx = Math.cos(angle) * speed;
          const vy = Math.sin(angle) * speed;

          invaderBullets.push(new InvaderBullet(this.pos.x, this.pos.y, vx, vy));
        }
      }

      draw(offsetX, offsetY) {
        ctx.save();
        ctx.translate(this.pos.x - offsetX, this.pos.y - offsetY);
        ctx.rotate(this.angle);
        
        ctx.fillStyle = this.color;
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 1;

        const s = this.size;

        // 1. Octopus Body (Square/Dome)
        ctx.beginPath();
        ctx.rect(-s/2, -s/2, s, s/2);
        ctx.fill();

        // 2. Head Dome
        ctx.beginPath();
        ctx.arc(0, -s/2, s/2, Math.PI, 2 * Math.PI);
        ctx.fill();

        // 3. Tentacles (simple lines/rects)
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 2;
        const tentacleCount = 4;
        for(let i = 0; i < tentacleCount; i++) {
          const xOffset = (i - tentacleCount/2 + 0.5) * s/4;
          ctx.beginPath();
          ctx.moveTo(xOffset, s/2);
          ctx.lineTo(xOffset, s/2 + s/3);
          ctx.stroke();
        }

        // 4. Eyes (small white dots)
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(-s/4, -s/4, s/8, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(s/4, -s/4, s/8, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
      }

      split() {
        if (this.size > 15) {
          const newSize = this.size / 2;
          return [
            new Invader(this.pos.x + newSize, this.pos.y, newSize),
            new Invader(this.pos.x - newSize, this.pos.y, newSize)
          ];
        }
        return [];
      }
    }

    function startGame(mode) {
      controlMode = mode;
      document.getElementById('startScreen').style.display = 'none';
      document.getElementById('hud').style.display = 'block';
      document.querySelector('.ship-select').style.display = 'flex';
      
      if (mode === 'mobile') {
        document.getElementById('joystick').style.display = 'block';
        document.getElementById('fireBtn').style.display = 'flex';
        setupTouchControls();
      } else {
        document.getElementById('controls').style.display = 'block';
        setupKeyboardControls();
      }

      ship = new Ship(WORLD_SIZE / 2, WORLD_SIZE / 2, 'fighter');
      
      for (let i = 0; i < INVADER_COUNT; i++) {
        const x = Math.random() * WORLD_SIZE;
        const y = Math.random() * WORLD_SIZE;
        const size = 20 + Math.random() * 25;
        invaders.push(new Invader(x, y, size));
      }

      gameOver = false;
      gameStarted = true;
      gameLoop();
    }
    
    function triggerGameOver() {
      if (gameOver) return;
      gameOver = true;
      document.getElementById('finalScore').textContent = `FINAL SCORE: ${score}`;
      document.getElementById('gameOverScreen').style.display = 'flex';
      document.getElementById('hud').style.display = 'none';
      document.querySelector('.ship-select').style.display = 'none';
      document.getElementById('joystick').style.display = 'none';
      document.getElementById('fireBtn').style.display = 'none';
      document.getElementById('controls').style.display = 'none';
      
      // Stop the game loop
      if (window.gameLoopRequest) cancelAnimationFrame(window.gameLoopRequest);
    }

    function setupTouchControls() {
      const joystick = document.getElementById('joystick');
      const knob = document.getElementById('joystick-knob');
      
      // Use 'pointer' events for better mobile compatibility across various devices
      joystick.addEventListener('pointerdown', handleJoystickStart);
      document.addEventListener('pointermove', handleJoystickMove);
      document.addEventListener('pointerup', handleJoystickEnd);

      let activePointerId = null;

      function handleJoystickStart(e) {
        if (activePointerId !== null) return;
        activePointerId = e.pointerId;
        e.preventDefault();
        joystickActive = true;
        handleJoystickMove(e);
      }

      function handleJoystickMove(e) {
        if (!joystickActive || e.pointerId !== activePointerId) return;
        e.preventDefault();
        
        const rect = joystick.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        
        const x = e.clientX - centerX;
        const y = e.clientY - centerY;
        
        const distance = Math.sqrt(x * x + y * y);
        const maxDistance = 35; // Half of knob width/height
        
        let normalizedX = x;
        let normalizedY = y;

        if (distance > maxDistance) {
          normalizedX = (x / distance) * maxDistance;
          normalizedY = (y / distance) * maxDistance;
          joystickDir.x = (x / distance);
          joystickDir.y = (y / distance);
        } else {
          joystickDir.x = x / maxDistance;
          joystickDir.y = y / maxDistance;
        }

        knob.style.transform = `translate(${normalizedX}px, ${normalizedY}px)`;
      }

      function handleJoystickEnd(e) {
        if (e.pointerId !== activePointerId) return;
        e.preventDefault();
        activePointerId = null;
        joystickActive = false;
        joystickDir = {x: 0, y: 0};
        knob.style.transform = 'translate(-50%, -50%)';
      }

      const fireBtn = document.getElementById('fireBtn');
      fireBtn.addEventListener('pointerdown', (e) => {
        e.preventDefault();
        firing = true;
        fireBtn.classList.add('active');
      });
      fireBtn.addEventListener('pointerup', (e) => {
        e.preventDefault();
        firing = false;
        fireBtn.classList.remove('active');
      });

      function updateFireButtonText() {
        if (ship && ship.type === 'carrier') {
          fireBtn.textContent = 'BOOST';
        } else {
          fireBtn.textContent = 'FIRE';
        }
      }
      updateFireButtonText();
      window.updateFireButtonText = updateFireButtonText;
    }

    function setupKeyboardControls() {
      window.addEventListener('keydown', e => {
        if (gameOver) return;
        keys[e.key.toLowerCase()] = true;
        if (e.key === '1') switchShip('fighter');
        if (e.key === '2') switchShip('carrier');
        if (e.key === '3') switchShip('brute');
      });
      
      window.addEventListener('keyup', e => {
        if (gameOver) return;
        keys[e.key.toLowerCase()] = false;
      });
    }

    document.querySelectorAll('.ship-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.preventDefault();
        switchShip(btn.dataset.ship);
      });
    });

    function switchShip(type) {
      if (!ship) return;
      const oldPos = ship.pos;
      const oldVel = ship.vel;
      ship = new Ship(oldPos.x, oldPos.y, type);
      ship.vel = oldVel;
      document.querySelectorAll('.ship-btn').forEach(b => b.classList.remove('active'));
      document.querySelector(`[data-ship="${type}"]`).classList.add('active');
      
      if (controlMode === 'mobile' && window.updateFireButtonText) {
        window.updateFireButtonText();
      }
    }

    function checkCollisions() {
      // Remove dead bullets
      invaderBullets = invaderBullets.filter(b => b.life > 0);

      // --- 1. Friendly Bullets vs Invaders ---
      ship.bullets = ship.bullets.filter(bullet => {
        let hit = false;
        invaders = invaders.filter(inv => {
          const dx = bullet.pos.x - inv.pos.x;
          const dy = bullet.pos.y - inv.pos.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < inv.size + bullet.radius) {
            hit = true;
            const newInvs = inv.split();
            invaders.push(...newInvs);
            score += 10;
            return false; // Remove the hit invader
          }
          return true; // Keep the invader
        });
        return !hit; // Remove the bullet if it hit something
      });

      // --- 2. Drone Bullets vs Invaders ---
      ship.drones.forEach(drone => {
        drone.bullets = drone.bullets.filter(bullet => {
          let hit = false;
          invaders = invaders.filter(inv => {
            const dx = bullet.pos.x - inv.pos.x;
            const dy = bullet.pos.y - inv.pos.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < inv.size + bullet.radius) {
              hit = true;
              const newInvs = inv.split();
              invaders.push(...newInvs);
              score += 5;
              return false;
            }
            return true;
          });
          return !hit;
        });

        // Drone collision with invaders
        invaders.forEach((inv, idx) => {
          const dx = drone.pos.x - inv.pos.x;
          const dy = drone.pos.y - inv.pos.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < inv.size + drone.radius) {
            // When a drone hits, the invader splits and the drone takes damage/life reduction
            const newInvs = inv.split();
            invaders.splice(idx, 1);
            invaders.push(...newInvs);
            drone.life -= 50;
            score += 3;
          }
        });
      });

      // --- 3. Invader Bullets vs Ship and Drones ---
      invaderBullets = invaderBullets.filter(ib => {
        // Ship collision
        const shipDx = ib.pos.x - ship.pos.x;
        const shipDy = ib.pos.y - ship.pos.y;
        const shipDist = Math.sqrt(shipDx * shipDx + shipDy * shipDy);
        if (shipDist < ship.hitRadius + ib.radius) {
          ship.health -= ib.damage;
          return false; // Remove invader bullet
        }

        // Drone collision
        for (let i = 0; i < ship.drones.length; i++) {
          const drone = ship.drones[i];
          const droneDx = ib.pos.x - drone.pos.x;
          const droneDy = ib.pos.y - drone.pos.y;
          const droneDist = Math.sqrt(droneDx * droneDx + droneDy * droneDy);
          if (droneDist < drone.radius + ib.radius) {
            drone.life -= 20;
            return false; // Remove invader bullet
          }
        }

        return true; // Keep invader bullet
      });

      // --- 4. Ship collision with invaders (Contact Damage) ---
      invaders.forEach(inv => {
        const dx = ship.pos.x - inv.pos.x;
        const dy = ship.pos.y - inv.pos.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < inv.size + ship.hitRadius) {
          ship.health -= 0.5;
        }
      });
    }

    function drawMinimap() {
      minimapCtx.fillStyle = '#000';
      minimapCtx.fillRect(0, 0, 100, 100);
      
      const scale = 100 / WORLD_SIZE;
      
      // Draw Invaders
      minimapCtx.fillStyle = '#f0f';
      invaders.forEach(inv => {
        minimapCtx.fillRect(inv.pos.x * scale - 1, inv.pos.y * scale - 1, 2, 2);
      });
      
      // Draw Player Ship
      minimapCtx.fillStyle = '#0f0';
      minimapCtx.fillRect(ship.pos.x * scale - 2, ship.pos.y * scale - 2, 4, 4);
    }
    
    function drawStars(offsetX, offsetY) {
      ctx.fillStyle = '#fff';
      const width = canvas.width;
      const height = canvas.height;

      for (const star of stars) {
        // Calculate star position relative to the viewport (0, 0)
        // Modulo operation provides the wrap-around effect, ensuring stars are always visible
        let drawX = (star.x - offsetX) % WORLD_SIZE;
        let drawY = (star.y - offsetY) % WORLD_SIZE;

        // Wrap around to the other side of the screen if they scroll off
        if (drawX < -star.size) drawX += WORLD_SIZE;
        if (drawY < -star.size) drawY += WORLD_SIZE;
        if (drawX > width) drawX -= WORLD_SIZE;
        if (drawY > height) drawY -= WORLD_SIZE;
        
        ctx.fillRect(drawX, drawY, star.size, star.size);
      }
    }

    function gameLoop() {
      window.gameLoopRequest = requestAnimationFrame(gameLoop);
      
      if (gameOver) {
        // Subtly fade the screen to reinforce game over state
        ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        return;
      }
      
      gameTime++;
      
      ship.update();
      invaders.forEach(inv => inv.update());
      invaderBullets.forEach(ib => ib.update());
      checkCollisions();

      const offsetX = ship.pos.x - canvas.width / 2;
      const offsetY = ship.pos.y - canvas.height / 2;

      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Draw stars (Performance optimized)
      drawStars(offsetX, offsetY);

      // Draw game objects
      invaders.forEach(inv => inv.draw(offsetX, offsetY));
      invaderBullets.forEach(ib => ib.draw(offsetX, offsetY));
      ship.draw(offsetX, offsetY);

      document.getElementById('score').textContent = score;
      document.getElementById('shipType').textContent = ship.type.toUpperCase();
      document.getElementById('health').textContent = Math.round(ship.health);

      drawMinimap();
    }
    
    // Ensure joystick knob returns to center on resize
    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      const knob = document.getElementById('joystick-knob');
      if (knob) knob.style.transform = 'translate(-50%, -50%)';
    });
  </script>
</body>
</html>
