<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Fleet Command: Invaders</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }
    body {
      overflow: hidden;
      background: #000;
      font-family: 'Courier New', monospace;
      touch-action: none;
    }
    #gameCanvas {
      display: block;
      background: #000;
      touch-action: none;
    }
    #startScreen, #gameOverScreen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      color: #0f0;
      text-align: center;
    }
    #startScreen h1 {
      font-size: 32px;
      margin-bottom: 5px;
      text-shadow: 0 0 10px #0f0;
    }
    #startScreen p {
      margin-bottom: 30px;
      font-size: 14px;
    }
    #gameOverScreen h1 {
      color: #f00;
      font-size: 48px;
      text-shadow: 0 0 15px #f00;
      margin-bottom: 20px;
    }
    #finalScore {
      font-size: 24px;
      margin-bottom: 30px;
      color: #0f0;
    }
    .mode-btn {
      background: rgba(0, 255, 0, 0.2);
      border: 2px solid #0f0;
      color: #0f0;
      padding: 15px 30px;
      margin: 10px;
      cursor: pointer;
      font-family: 'Courier New', monospace;
      font-size: 16px;
      font-weight: bold;
      text-transform: uppercase;
    }
    .mode-btn:hover {
      background: rgba(0, 255, 0, 0.4);
    }
    #hud {
      position: absolute;
      top: 10px;
      left: 10px;
      color: #0f0;
      font-size: 12px;
      text-shadow: 0 0 5px #0f0;
      pointer-events: none;
      z-index: 10;
    }
    #minimap {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      width: 100px;
      height: 100px;
      border: 2px solid #0f0;
      background: rgba(0, 0, 0, 0.7);
      z-index: 10;
    }
    .ship-select {
      position: absolute;
      top: 10px;
      right: 10px;
      display: flex;
      flex-direction: column;
      gap: 5px;
      z-index: 10;
    }
    .ship-btn {
      background: rgba(0, 255, 0, 0.2);
      border: 1px solid #0f0;
      color: #0f0;
      padding: 8px 12px;
      cursor: pointer;
      font-family: 'Courier New', monospace;
      font-size: 11px;
      touch-action: manipulation;
    }
    .ship-btn.active {
      background: rgba(0, 255, 0, 0.6);
    }
    #joystick {
      position: absolute;
      bottom: 20px;
      left: 20px;
      width: 120px;
      height: 120px;
      background: rgba(0, 255, 0, 0.1);
      border: 2px solid rgba(0, 255, 0, 0.3);
      border-radius: 50%;
      z-index: 10;
      display: none;
    }
    #joystick-knob {
      position: absolute;
      width: 50px;
      height: 50px;
      background: rgba(0, 255, 0, 0.5);
      border: 2px solid #0f0;
      border-radius: 50%;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
    #fireBtn {
      position: absolute;
      bottom: 20px;
      right: 5px;
      width: 80px;
      height: 80px;
      background: rgba(255, 0, 0, 0.3);
      border: 2px solid #f00;
      border-radius: 50%;
      color: #f00;
      font-size: 12px;
      font-weight: bold;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 10;
      touch-action: manipulation;
    }
    #fireBtn.active {
      background: rgba(255, 0, 0, 0.6);
    }
    #controls {
      position: absolute;
      bottom: 10px;
      left: 10px;
      color: #0f0;
      font-size: 11px;
      text-shadow: 0 0 5px #0f0;
      display: none;
    }
  </style>
</head>
<body>
  <div id="startScreen">
    <h1>FLEET COMMAND: INVADERS</h1>
        <p style="font-size: 12px; margin-bottom: 30px; color: #0f0; text-shadow: 0 0 5px #0f0;">
      Made by **Patrick McDonald** and a **Legion of AI**
    </p>
    <p>Choose your control mode:</p>
    <button class="mode-btn" onclick="startGame('mobile')">MOBILE (Touch)</button>
    <button class="mode-btn" onclick="startGame('desktop')">DESKTOP (Keyboard)</button>
  </div>

    <div id="gameOverScreen" style="display: none;">
    <h1>SHIP DESTROYED!</h1>
    <div id="finalScore">FINAL SCORE: 0</div>
    <button class="mode-btn" onclick="window.location.reload()">RE-INITIALIZE PROTOCOL</button>
  </div>

  <canvas id="gameCanvas"></canvas>
  <canvas id="minimap"></canvas>
  
  <div id="hud">
    <div>SCORE: <span id="score">0</span></div>
    <div>SHIP: <span id="shipType">FIGHTER</span></div>
    <div>HULL: <span id="health">100</span>%</div>
  </div>
  
  <div class="ship-select">
    <button class="ship-btn active" data-ship="fighter">FIGHTER</button>
    <button class="ship-btn" data-ship="carrier">CARRIER</button>
    <button class="ship-btn" data-ship="brute">BRUTE</button>
  </div>

  <div id="joystick">
    <div id="joystick-knob"></div>
  </div>
  
  <button id="fireBtn">FIRE</button>
  
  <div id="controls">WASD: Move | SPACE: Fire (Fighter/Brute) or Boost (Carrier) | 1/2/3: Switch Ship</div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const minimap = document.getElementById('minimap');
    const minimapCtx = minimap.getContext('2d');
    
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // MODIFICATION 3: Doubled the map size from 1000 to 2000
    const WORLD_SIZE = 2000;
    const INVADER_COUNT = 80;

    let score = 0;
    let gameTime = 0;
    let joystickActive = false;
    let joystickDir = {x: 0, y: 0};
    let firing = false;
    let controlMode = null;
    let keys = {};
    let invaders = [];
    let invaderBullets = [];
    let ship = null;
    let gameStarted = false;
    let gameOver = false; // New state variable

    class Vector {
      constructor(x, y) {
        this.x = x;
        this.y = y;
      }
      add(v) { return new Vector(this.x + v.x, this.y + v.y); }
      mult(s) { return new Vector(this.x * s, this.y * s); }
      mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
      normalize() { const m = this.mag(); return m > 0 ? this.mult(1/m) : new Vector(0, 0); }
    }

    class Ship {
      constructor(x, y, type) {
        this.pos = new Vector(x, y);
        this.vel = new Vector(0, 0);
        this.angle = 0;
        this.type = type;
        this.bullets = [];
        this.drones = [];
        
        if (type === 'fighter') {
          this.maxSpeed = 6;
          this.accel = 0.25;
          this.health = 100;
          this.maxHealth = 100;
          this.fireRate = 5;
          this.size = 12;
          this.hitRadius = 10;
        } else if (type === 'carrier') {
          this.maxSpeed = 3;
          this.accel = 0.12;
          this.health = 250;
          this.maxHealth = 250;
          this.fireRate = 320;
          this.size = 20;
          this.hitRadius = 18;
          this.boostPower = 0.5;
          this.maxBoostSpeed = 7;
        } else if (type === 'brute') {
          this.maxSpeed = 5;
          this.accel = 0.2;
          this.health = 150;
          this.maxHealth = 150;
          this.fireRate = 53;
          this.size = 14;
          this.hitRadius = 12;
        }
        
        this.lastFire = 0;
      }

      update() {
        if (controlMode === 'mobile') {
          if (joystickDir.x !== 0 || joystickDir.y !== 0) {
            const dir = new Vector(joystickDir.x, joystickDir.y).normalize();
            this.angle = Math.atan2(dir.y, dir.x);
            this.vel = this.vel.add(dir.mult(this.accel));
          }
        } else {
          const dir = new Vector(0, 0);
          if (keys['w'] || keys['W']) dir.y -= 1;
          if (keys['s'] || keys['S']) dir.y += 1;
          if (keys['a'] || keys['A']) dir.x -= 1;
          if (keys['d'] || keys['D']) dir.x += 1;

          if (dir.mag() > 0) {
            this.angle = Math.atan2(dir.y, dir.x);
            const force = dir.normalize().mult(this.accel);
            this.vel = this.vel.add(force);
          }
        }

        // Boost for carrier (desktop/mobile)
        if (this.type === 'carrier' && ((controlMode === 'desktop' && keys[' ']) || (controlMode === 'mobile' && firing))) {
          const boostDir = new Vector(Math.cos(this.angle), Math.sin(this.angle));
          this.vel = this.vel.add(boostDir.mult(this.boostPower));
          
          if (this.vel.mag() > this.maxBoostSpeed) {
            this.vel = this.vel.normalize().mult(this.maxBoostSpeed);
          }
        } else {
          // Normal speed limit
          if (this.vel.mag() > this.maxSpeed) {
            this.vel = this.vel.normalize().mult(this.maxSpeed);
          }
        }

        this.vel = this.vel.mult(0.97);
        this.pos = this.pos.add(this.vel);

        // Wrap around world limits
        if (this.pos.x < 0) this.pos.x = WORLD_SIZE;
        if (this.pos.x > WORLD_SIZE) this.pos.x = 0;
        if (this.pos.y < 0) this.pos.y = WORLD_SIZE;
        if (this.pos.y > WORLD_SIZE) this.pos.y = 0;

        // Fire logic (Desktop or Mobile manual fire)
        const shouldFire = (controlMode === 'desktop' && this.type !== 'carrier' && keys[' ']) ||
                         (controlMode === 'mobile' && this.type !== 'carrier' && firing);
        
        if (shouldFire && gameTime - this.lastFire > this.fireRate) {
          this.fire();
          this.lastFire = gameTime;
        }

        this.bullets = this.bullets.filter(b => {
          b.update();
          return b.life > 0;
        });

        this.drones = this.drones.filter(d => {
          d.update(this.pos);
          return d.life > 0;
        });

        if (this.type === 'carrier' && this.drones.length < 3 && gameTime % 150 === 0) {
          this.drones.push(new Drone(this.pos.x, this.pos.y));
        }

        // MODIFICATION 4: Game Over Check
        if (this.health <= 0) {
          triggerGameOver();
        }
      }

      fire() {
        const speed = 12;
        const shipVel = this.vel;
        
        if (this.type === 'fighter') {
          const vx = Math.cos(this.angle) * speed + shipVel.x;
          const vy = Math.sin(this.angle) * speed + shipVel.y;
          this.bullets.push(new Bullet(this.pos.x, this.pos.y, vx, vy, '#00ff00'));
        } else if (this.type === 'brute') {
          for (let i = -2; i <= 2; i++) {
            const angle = this.angle + i * 0.2;
            const vx = Math.cos(angle) * speed + shipVel.x;
            const vy = Math.sin(angle) * speed + shipVel.y;
            this.bullets.push(new Bullet(this.pos.x, this.pos.y, vx, vy, '#ff4400'));
          }
        }
      }

      draw(offsetX, offsetY) {
        ctx.save();
        ctx.translate(this.pos.x - offsetX, this.pos.y - offsetY);
        ctx.rotate(this.angle);
        
        if (this.type === 'fighter') {
          ctx.fillStyle = '#00ff00';
          ctx.beginPath();
          ctx.moveTo(this.size, 0);
          ctx.lineTo(-this.size, this.size/2);
          ctx.lineTo(-this.size/2, 0);
          ctx.lineTo(-this.size, -this.size/2);
          ctx.closePath();
          ctx.fill();
        } 
        // MODIFICATION 5: New Carrier Design
        else if (this.type === 'carrier') {
          const s = this.size;
          // Main Hull
          ctx.fillStyle = '#0088ff';
          ctx.fillRect(-s*1.5, -s/4, s*3, s/2);
          // Cockpit/Bridge
          ctx.fillStyle = '#00aaff';
          ctx.fillRect(s, -s/2, s/2, s);
          // Engine Thrusters
          ctx.fillStyle = '#ff0000';
          ctx.beginPath();
          ctx.moveTo(-s*1.5, -s/4);
          ctx.lineTo(-s*1.8, -s/2);
          ctx.lineTo(-s*1.8, s/2);
          ctx.lineTo(-s*1.5, s/4);
          ctx.fill();
          ctx.fillStyle = '#ff9900';
          ctx.fillRect(-s*1.7, -s/4, s*0.2, s/2); // Glow
        } 
        else if (this.type === 'brute') {
          ctx.fillStyle = '#ff4400';
          ctx.beginPath();
          ctx.moveTo(this.size, 0);
          ctx.lineTo(-this.size, this.size);
          ctx.lineTo(-this.size, -this.size);
          ctx.closePath();
          ctx.fill();
          ctx.fillStyle = '#ff6622';
          ctx.fillRect(-this.size * 0.7, -this.size * 0.5, this.size * 1.4, this.size);
        }
        
        ctx.restore();

        this.bullets.forEach(b => b.draw(offsetX, offsetY));
        this.drones.forEach(d => d.draw(offsetX, offsetY));
      }
    }

    class Bullet {
      constructor(x, y, vx, vy, color = '#ffff00') {
        this.pos = new Vector(x, y);
        this.vel = new Vector(vx, vy);
        this.life = 100;
        this.color = color;
        this.radius = 3;
      }

      update() {
        this.pos = this.pos.add(this.vel);
        this.life--;
      }

      draw(offsetX, offsetY) {
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.pos.x - offsetX, this.pos.y - offsetY, this.radius, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    class InvaderBullet extends Bullet {
      constructor(x, y, vx, vy) {
        super(x, y, vx, vy, '#ff00ff');
        this.radius = 4;
        this.damage = 5;
      }
    }

    class Drone {
      constructor(x, y) {
        this.pos = new Vector(x, y);
        this.vel = new Vector(0, 0);
        this.life = 400;
        this.orbitAngle = Math.random() * Math.PI * 2;
        this.bullets = [];
        this.lastFire = 0;
        this.radius = 6;
      }

      update(parentPos) {
        this.orbitAngle += 0.04;
        const targetX = parentPos.x + Math.cos(this.orbitAngle) * 50;
        const targetY = parentPos.y + Math.sin(this.orbitAngle) * 50;
        
        this.vel.x += (targetX - this.pos.x) * 0.02;
        this.vel.y += (targetY - this.pos.y) * 0.02;
        this.vel = this.vel.mult(0.88);
        this.pos = this.pos.add(this.vel);
        this.life--;

        // Auto-fire at invaders
        if (gameTime - this.lastFire > 50) {
          const nearest = this.findNearestInvader();
          if (nearest && nearest.dist < 300) {
            this.fireAt(nearest.invader);
            this.lastFire = gameTime;
          }
        }

        this.bullets = this.bullets.filter(b => {
          b.update();
          return b.life > 0;
        });
      }

      findNearestInvader() {
        let nearest = null;
        let minDist = Infinity;
        invaders.forEach(inv => {
          const dx = inv.pos.x - this.pos.x;
          const dy = inv.pos.y - this.pos.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < minDist) {
            minDist = dist;
            nearest = { invader: inv, dist: dist };
          }
        });
        return nearest;
      }

      fireAt(invader) {
        const dx = invader.pos.x - this.pos.x;
        const dy = invader.pos.y - this.pos.y;
        const angle = Math.atan2(dy, dx);
        const speed = 9;
        const vx = Math.cos(angle) * speed;
        const vy = Math.sin(angle) * speed;
        this.bullets.push(new Bullet(this.pos.x, this.pos.y, vx, vy, '#00ffff'));
      }

      draw(offsetX, offsetY) {
        const x = this.pos.x - offsetX;
        const y = this.pos.y - offsetY;
        ctx.fillStyle = '#00ffff';
        ctx.strokeStyle = '#00ffff';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(x, y, this.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();

        this.bullets.forEach(b => b.draw(offsetX, offsetY));
      }
    }

    class Invader {
      constructor(x, y, size) {
        this.pos = new Vector(x, y);
        this.vel = new Vector((Math.random() - 0.5) * 1.5, (Math.random() - 0.5) * 1.5);
        this.size = size;
        this.angle = Math.random() * Math.PI * 2;
        this.rotSpeed = (Math.random() - 0.5) * 0.08;
        this.color = '#ff00ff';
        
        // MODIFICATION 6: Slower fire rate (increased from ~250 to ~350)
        this.fireRate = 300 + Math.random() * 100; 
        this.lastFire = gameTime + Math.random() * this.fireRate;
      }

      update() {
        this.pos = this.pos.add(this.vel);
        this.angle += this.rotSpeed;

        // Wrap around world limits
        if (this.pos.x < 0) this.pos.x = WORLD_SIZE;
        if (this.pos.x > WORLD_SIZE) this.pos.x = 0;
        if (this.pos.y < 0) this.pos.y = WORLD_SIZE;
        if (this.pos.y > WORLD_SIZE) this.pos.y = 0;

        // Firing logic
        if (gameTime - this.lastFire > this.fireRate) {
          this.fire();
          this.lastFire = gameTime;
        }
      }

      fire() {
        const dx = ship.pos.x - this.pos.x;
        const dy = ship.pos.y - this.pos.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < 800) {
          const angle = Math.atan2(dy, dx);
          const speed = 7;
          const vx = Math.cos(angle) * speed;
          const vy = Math.sin(angle) * speed;

          invaderBullets.push(new InvaderBullet(this.pos.x, this.pos.y, vx, vy));
        }
      }

      draw(offsetX, offsetY) {
        ctx.save();
        ctx.translate(this.pos.x - offsetX, this.pos.y - offsetY);
        ctx.rotate(this.angle);
        
        ctx.fillStyle = this.color;
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 1;

        const s = this.size;

        // 1. Octopus Body (Square/Dome)
        ctx.beginPath();
        ctx.rect(-s/2, -s/2, s, s/2);
        ctx.fill();

        // 2. Head Dome
        ctx.beginPath();
        ctx.arc(0, -s/2, s/2, Math.PI, 2 * Math.PI);
        ctx.fill();

        // 3. Tentacles (simple lines/rects)
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 2;
        const tentacleCount = 4;
        for(let i = 0; i < tentacleCount; i++) {
          const xOffset = (i - tentacleCount/2 + 0.5) * s/4;
          ctx.beginPath();
          ctx.moveTo(xOffset, s/2);
          ctx.lineTo(xOffset, s/2 + s/3);
          ctx.stroke();
        }

        // 4. Eyes (small white dots)
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(-s/4, -s/4, s/8, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(s/4, -s/4, s/8, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
      }

      split() {
        if (this.size > 15) {
          const newSize = this.size / 2;
          return [
            new Invader(this.pos.x + newSize, this.pos.y, newSize),
            new Invader(this.pos.x - newSize, this.pos.y, newSize)
          ];
        }
        return [];
      }
    }

    function startGame(mode) {
      controlMode = mode;
      document.getElementById('startScreen').style.display = 'none';
      document.getElementById('hud').style.display = 'block';
      document.querySelector('.ship-select').style.display = 'flex';
      
      if (mode === 'mobile') {
        document.getElementById('joystick').style.display = 'block';
        document.getElementById('fireBtn').style.display = 'flex';
        setupTouchControls();
      } else {
        document.getElementById('controls').style.display = 'block';
        setupKeyboardControls();
      }

      ship = new Ship(WORLD_SIZE / 2, WORLD_SIZE / 2, 'fighter');
      
      for (let i = 0; i < INVADER_COUNT; i++) {
        const x = Math.random() * WORLD_SIZE;
        const y = Math.random() * WORLD_SIZE;
        const size = 20 + Math.random() * 25;
        invaders.push(new Invader(x, y, size));
      }

      gameOver = false;
      gameStarted = true;
      gameLoop();
    }
    
    // MODIFICATION 7: Death Sequence Function
    function triggerGameOver() {
      if (gameOver) return;
      gameOver = true;
      document.getElementById('finalScore').textContent = `FINAL SCORE: ${score}`;
      document.getElementById('gameOverScreen').style.display = 'flex';
      document.getElementById('hud').style.display = 'none';
      document.querySelector('.ship-select').style.display = 'none';
      document.getElementById('joystick').style.display = 'none';
      document.getElementById('fireBtn').style.display = 'none';
      document.getElementById('controls').style.display = 'none';
    }

    function setupTouchControls() {
      const joystick = document.getElementById('joystick');
      const knob = document.getElementById('joystick-knob');
      
      joystick.addEventListener('touchstart', handleJoystickStart);
      joystick.addEventListener('touchmove', handleJoystickMove);
      joystick.addEventListener('touchend', handleJoystickEnd);

      function handleJoystickStart(e) {
        e.preventDefault();
        joystickActive = true;
        handleJoystickMove(e);
      }

      function handleJoystickMove(e) {
        if (!joystickActive) return;
        e.preventDefault();
        
        const rect = joystick.getBoundingClientRect();
        const centerX = rect.width / 2;
        const centerY = rect.height / 2;
        const touch = e.touches[0];
        const x = touch.clientX - rect.left - centerX;
        const y = touch.clientY - rect.top - centerY;
        
        const distance = Math.sqrt(x * x + y * y);
        const maxDistance = 35;
        
        if (distance > maxDistance) {
          joystickDir.x = (x / distance);
          joystickDir.y = (y / distance);
          knob.style.transform = `translate(${(x / distance) * maxDistance}px, ${(y / distance) * maxDistance}px)`;
        } else {
          joystickDir.x = x / maxDistance;
          joystickDir.y = y / maxDistance;
          knob.style.transform = `translate(${x}px, ${y}px)`;
        }
      }

      function handleJoystickEnd(e) {
        e.preventDefault();
        joystickActive = false;
        joystickDir = {x: 0, y: 0};
        knob.style.transform = 'translate(0, 0)';
      }

      const fireBtn = document.getElementById('fireBtn');
      fireBtn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        firing = true;
        fireBtn.classList.add('active');
      });
      fireBtn.addEventListener('touchend', (e) => {
        e.preventDefault();
        firing = false;
        fireBtn.classList.remove('active');
      });

      function updateFireButtonText() {
        if (ship && ship.type === 'carrier') {
          fireBtn.textContent = 'BOOST';
        } else {
          fireBtn.textContent = 'FIRE';
        }
      }
      updateFireButtonText();
      window.updateFireButtonText = updateFireButtonText;
    }

    function setupKeyboardControls() {
      window.addEventListener('keydown', e => {
        keys[e.key] = true;
        if (e.key === '1') switchShip('fighter');
        if (e.key === '2') switchShip('carrier');
        if (e.key === '3') switchShip('brute');
      });
      
      window.addEventListener('keyup', e => keys[e.key] = false);
    }

    document.querySelectorAll('.ship-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.preventDefault();
        switchShip(btn.dataset.ship);
      });
    });

    function switchShip(type) {
      if (!ship) return;
      const oldPos = ship.pos;
      const oldVel = ship.vel;
      ship = new Ship(oldPos.x, oldPos.y, type);
      ship.vel = oldVel;
      document.querySelectorAll('.ship-btn').forEach(b => b.classList.remove('active'));
      document.querySelector(`[data-ship="${type}"]`).classList.add('active');
      
      if (controlMode === 'mobile' && window.updateFireButtonText) {
        window.updateFireButtonText();
      }
    }

    function checkCollisions() {
      // Remove dead bullets
      invaderBullets = invaderBullets.filter(b => b.life > 0);

      // --- 1. Friendly Bullets vs Invaders ---
      ship.bullets = ship.bullets.filter(bullet => {
        let hit = false;
        invaders = invaders.filter(inv => {
          const dx = bullet.pos.x - inv.pos.x;
          const dy = bullet.pos.y - inv.pos.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < inv.size + bullet.radius) {
            hit = true;
            const newInvs = inv.split();
            invaders.push(...newInvs);
            score += 10;
            return false; // Remove the hit invader
          }
          return true; // Keep the invader
        });
        return !hit; // Remove the bullet if it hit something
      });

      // --- 2. Drone Bullets vs Invaders ---
      ship.drones.forEach(drone => {
        drone.bullets = drone.bullets.filter(bullet => {
          let hit = false;
          invaders = invaders.filter(inv => {
            const dx = bullet.pos.x - inv.pos.x;
            const dy = bullet.pos.y - inv.pos.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < inv.size + bullet.radius) {
              hit = true;
              const newInvs = inv.split();
              invaders.push(...newInvs);
              score += 5;
              return false;
            }
            return true;
          });
          return !hit;
        });

        // Drone collision with invaders
        invaders.forEach((inv, idx) => {
          const dx = drone.pos.x - inv.pos.x;
          const dy = drone.pos.y - inv.pos.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < inv.size + drone.radius) {
            // When a drone hits, the invader splits and the drone takes damage/life reduction
            const newInvs = inv.split();
            invaders.splice(idx, 1);
            invaders.push(...newInvs);
            drone.life -= 50;
            score += 3;
          }
        });
      });

      // --- 3. Invader Bullets vs Ship and Drones ---
      invaderBullets = invaderBullets.filter(ib => {
        // Ship collision
        const shipDx = ib.pos.x - ship.pos.x;
        const shipDy = ib.pos.y - ship.pos.y;
        const shipDist = Math.sqrt(shipDx * shipDx + shipDy * shipDy);
        if (shipDist < ship.hitRadius + ib.radius) {
          ship.health -= ib.damage;
          return false; // Remove invader bullet
        }

        // Drone collision
        for (let i = 0; i < ship.drones.length; i++) {
          const drone = ship.drones[i];
          const droneDx = ib.pos.x - drone.pos.x;
          const droneDy = ib.pos.y - drone.pos.y;
          const droneDist = Math.sqrt(droneDx * droneDx + droneDy * droneDy);
          if (droneDist < drone.radius + ib.radius) {
            drone.life -= 20;
            return false; // Remove invader bullet
          }
        }

        return true; // Keep invader bullet
      });

      // --- 4. Ship collision with invaders (Contact Damage) ---
      invaders.forEach(inv => {
        const dx = ship.pos.x - inv.pos.x;
        const dy = ship.pos.y - inv.pos.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < inv.size + ship.hitRadius) {
          ship.health -= 0.5;
        }
      });
    }

    function drawMinimap() {
      minimapCtx.fillStyle = '#000';
      minimapCtx.fillRect(0, 0, 100, 100);
      
      const scale = 100 / WORLD_SIZE;
      
      // Draw Invaders
      minimapCtx.fillStyle = '#f0f';
      invaders.forEach(inv => {
        minimapCtx.fillRect(inv.pos.x * scale - 1, inv.pos.y * scale - 1, 2, 2);
      });
      
      // Draw Player Ship
      minimapCtx.fillStyle = '#0f0';
      minimapCtx.fillRect(ship.pos.x * scale - 2, ship.pos.y * scale - 2, 4, 4);
    }

    function gameLoop() {
      if (!gameStarted || gameOver) {
        if (gameOver) {
          // If game is over, keep the last frame drawn or show a subtle screen effect
          ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        return;
      }
      
      gameTime++;
      
      ship.update();
      invaders.forEach(inv => inv.update());
      invaderBullets.forEach(ib => ib.update());
      checkCollisions();

      const offsetX = ship.pos.x - canvas.width / 2;
      const offsetY = ship.pos.y - canvas.height / 2;

      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Draw everything
      invaders.forEach(inv => inv.draw(offsetX, offsetY));
      invaderBullets.forEach(ib => ib.draw(offsetX, offsetY));
      ship.draw(offsetX, offsetY);

      // Draw stars (background detail)
      for (let i = 0; i < 150; i++) {
        const starX = (Math.random() * WORLD_SIZE - offsetX) % canvas.width;
        const starY = (Math.random() * WORLD_SIZE - offsetY) % canvas.height;
        ctx.fillStyle = '#fff';
        ctx.fillRect(starX < 0 ? starX + canvas.width : starX, starY < 0 ? starY + canvas.height : starY, 1, 1);
      }

      document.getElementById('score').textContent = score;
      document.getElementById('shipType').textContent = ship.type.toUpperCase();
      document.getElementById('health').textContent = Math.round(ship.health);

      drawMinimap();

      requestAnimationFrame(gameLoop);
    }

    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    });
  </script>
</body>
</html>
