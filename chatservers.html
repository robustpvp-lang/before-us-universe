<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>BUU — Boot + Chat (Unified)</title>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
<style>
:root{
  --bg:#001a1a; --fg:#00ffff; --accent:#ffcc00; --border:#00cccc; --panel-bg:#002b2b;
  --text-gray:#e6f7f7; --muted:#00aaaa; --online:#00ff9d; --yahoo-blue:#1e73be; --yahoo-dark:#0961a6;
}
html,body{margin:0;height:100%;font-family:'Roboto Mono',monospace;background:var(--bg);color:var(--fg);overflow:hidden}
body{background:url('https://wallpapercave.com/wp/wp4468245.jpg') center/cover no-repeat}
.panel{border:3px solid var(--border); background: var(--panel-bg); border-radius:6px; box-shadow:0 0 14px rgba(0,255,255,0.06); padding:8px}
.panel-title{display:flex;align-items:center;justify-content:space-between;padding:6px;background:linear-gradient(90deg,var(--yahoo-blue),var(--yahoo-dark));color:#fff;font-family:'Press Start 2P';font-size:12px}
.chat-win{display:flex;flex-direction:column;height:calc(100vh - 40px);margin:20px}
.chat-main{display:flex;flex:1;overflow:hidden;background:rgba(255,255,255,0.02);border-radius:4px}
.chat-messages{flex:1;overflow:auto;padding:12px;color:#000;background:rgba(255,255,255,0.95);border-right:1px solid rgba(0,0,0,0.06)}
.chat-users{width:220px;overflow:auto;padding:8px;background:#fffacd}
.chat-row{display:flex;gap:8px;margin:8px 0;align-items:flex-start}
.chat-avatar{width:36px;height:36px;border-radius:50%;background:#add8e6;display:flex;align-items:center;justify-content:center;font-weight:700;font-size:12px;color:#001a1a}
.chat-bubble{max-width:78%;padding:10px;border-radius:8px;background:#e6e6fa;border:1px solid rgba(0,0,0,0.06);color:#000}
.chat-bubble.me{background:#fffacd;border:1px solid #f0d280;text-align:right;color:#222}
.chat-meta{font-size:11px;color:#808080;font-weight:700;margin-bottom:4px}
.user-row{display:flex;gap:8px;align-items:center;padding:6px;font-size:12px;cursor:pointer}
.status-dot{width:9px;height:9px;border-radius:50%;background:var(--online)}
.uname{font-family:'Press Start 2P';color:#ff0000;font-size:12px}
.chat-controls{display:flex;gap:6px;padding:8px;background:#fffacd;border-top:1px solid rgba(0,0,0,0.06)}
.chat-controls input{flex:1;padding:8px;border:2px inset rgba(0,0,0,0.06);background:#fff;color:#000}
.chat-controls button{padding:8px;border:2px outset rgba(0,0,0,0.06);background:#add8e6;cursor:pointer;color:#000}
.small{font-size:11px;color:var(--muted)}
.typing-indicator { font-size: 12px; color: var(--muted); padding: 6px; font-style: italic; }

/* Boot overlay */
#bootOverlay{position:fixed;inset:0;background:linear-gradient(180deg,rgba(0,0,0,0.9),rgba(0,0,0,0.95));color:var(--fg);z-index:99999;display:flex;align-items:center;justify-content:center;flex-direction:column;font-family:'Roboto Mono',monospace}
#bootPanel{width:92%;max-width:820px;background:var(--panel-bg);border:4px solid var(--border);padding:18px;box-shadow:0 0 30px rgba(0,255,255,0.06)}
#bootLog{line-height:1.6;white-space:pre-wrap;margin-bottom:12px;font-size:13px;color:var(--text-gray)}
#bootPrompt{color:var(--accent);margin-bottom:6px;animation:blink 1s step-end infinite;}
@keyframes blink{50%{opacity:0;}}
#bootInputs{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
#bootInput,#bootChannel{background:#001f1f;border:2px solid var(--border);color:var(--fg);padding:8px;width:48%;min-width:160px;font-family:monospace}
#bootBtn{background:var(--accent);border:2px solid #000;color:#000;padding:8px 14px;cursor:pointer;font-weight:700}
#bootBanner{margin-top:10px;background:rgba(0,0,0,0.35);padding:8px;border-radius:4px;color:var(--fg);font-size:12px}
#bootStatus{margin-top:8px;color:var(--accent)}
@media(max-width:900px){ .chat-users{display:none} .chat-controls{flex-direction:column} #bootInput,#bootChannel{width:100%} }
</style>
</head>
<body>
  <!-- Boot overlay collects handle + channel; signs in anonymously (hidden) and then initializes chat -->
  <div id="bootOverlay">
    <div id="bootPanel">
      <div id="bootLog" class="small"></div>
      <div id="bootPrompt">> ENTER HANDLE & SELECT SERVER</div>
      <div id="bootInputs">
        <input id="bootInput" type="text" maxlength="30" placeholder="//YourHandle (required)">
        <select id="bootChannel">
          <option value="sam">//Sam</option>
          <option value="exuro">//Exuro</option>
          <option value="nero">//Nero</option>
          <option value="nora">//Nora</option>
          <option value="loktal">//Loktal</option>
        </select>
        <button id="bootBtn">ENTER NETWORK</button>
      </div>
      <div id="bootStatus" class="small"></div>
      <div id="bootBanner" class="small">System Broadcast: <span id="bootBroadcast">Timeline stability.. 84%</span></div>
    </div>
  </div>

  <!-- Main chat UI -->
  <div class="panel" style="margin:12px">
    <div class="panel-title"><div class="title" id="chatTitle">//SAM <span class="small" id="userCountSmall">0 users</span></div></div>
  </div>

  <div class="chat-win panel" id="chatBody" style="margin:12px;padding:0">
    <div class="chat-main">
      <div class="chat-messages panel" id="chatMessages" aria-live="polite"></div>
      <div class="chat-users panel">
        <div class="small" style="margin-bottom:6px">USERS ONLINE</div>
        <div id="activeUsersList"></div>
      </div>
    </div>
    <div id="typingIndicator" class="typing-indicator"></div>
    <div class="chat-controls">
      <input id="chatInput" placeholder="Say something..." maxlength="500" autocomplete="off" aria-label="Chat input">
      <button id="sendBtn" aria-label="Send message">SEND</button>
    </div>
  </div>

<script type="module">
/*
  Unified Boot + Chat
  - Anonymous Firebase auth (hidden) for online presence & secure DB writes
  - Handle and selected channel come from boot overlay
  - No guest fallback; must use boot overlay handle
  - Renamed post function to postChatMessage to avoid window.postMessage collisions
  - Defensive logging and error handlers included
*/

import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import {
  getDatabase, ref, push, set, onChildAdded, onValue, remove, onDisconnect, update, get, off, onChildRemoved, query, orderByChild
} from "https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js";
import { getAuth, onAuthStateChanged, signInAnonymously } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";

/* ---------- Config ---------- */
const firebaseConfig = {
  apiKey:"AIzaSyBGdiOrMFolYWNMvckE4fbp_VhWA80BaII",
  authDomain:"before-us-universe.firebaseapp.com",
  databaseURL:"https://before-us-universe-default-rtdb.firebaseio.com",
  projectId:"before-us-universe",
  storageBucket:"before-us-universe.firebasestorage.app",
  messagingSenderId:"477103463228",
  appId:"1:477103463228:web:01b53b6b29cb9d54315c39"
};

const app = initializeApp(firebaseConfig);
const db = getDatabase(app);
const auth = getAuth(app);

/* ---------- DOM ---------- */
const bootOverlay = document.getElementById('bootOverlay');
const bootLog = document.getElementById('bootLog');
const bootInput = document.getElementById('bootInput');
const bootBtn = document.getElementById('bootBtn');
const bootStatus = document.getElementById('bootStatus');
const bootBroadcast = document.getElementById('bootBroadcast');
const bootChannel = document.getElementById('bootChannel');

const chatMessages = document.getElementById('chatMessages');
const chatInput = document.getElementById('chatInput');
const sendBtn = document.getElementById('sendBtn');
const userCountSmall = document.getElementById('userCountSmall');
const activeUsersList = document.getElementById('activeUsersList');
const chatTitle = document.getElementById('chatTitle');
const typingIndicator = document.getElementById('typingIndicator');

/* ---------- State ---------- */
let uid = null, myHandle = null, currentChannel = 'sam', presenceRef = null;
let channelListeners = {};
let typingTimeout = null;
let idleTimer = null;

/* ---------- Boot typing lines ---------- */
const bootLines = [
  "C:\\> INITIALIZING BEFORE US UNIVERSE...",
  "C:\\> Loading kernel.............[ONLINE]",
  "C:\\> Checking Ra'Norric link....[ONLINE]",
  "C:\\> Accessing Pre-Universe Archives... [GRANTED]",
  "C:\\> Loading Melphia's Game Protocols... [ACTIVE]",
  "C:\\> Detecting Temporal Anomalies... [STABLE]",
  "C:\\> MEMORY CHECK PASSED",
  "C:\\> DISK VERIFIED",
  "C:\\> NETWORK ACTIVE",
  "C:\\> System is .....[ONLINE]",
  "C:\\> Ready for authentication..."
];
let lineIdx = 0;
function typeBootLine(){
  if(lineIdx < bootLines.length){
    bootLog.textContent += bootLines[lineIdx] + "\n";
    lineIdx++;
    setTimeout(typeBootLine, 220 + Math.random()*300);
  }
}
typeBootLine();
setInterval(() => {
  const p = 80 + Math.floor(Math.random() * 11);
  bootBroadcast.textContent = `Timeline stability.. ${p}%`;
}, 5000);

/* ---------- Utility functions ---------- */
function esc(s){ return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }
async function sha256Hex(msg){
  const e = new TextEncoder().encode(msg);
  const b = await crypto.subtle.digest('SHA-256', e);
  return Array.from(new Uint8Array(b)).map(x => x.toString(16).padStart(2,'0')).join('');
}
async function hash(str){
  return sha256Hex(str);
}

/* ---------- Presence & Online Watch ---------- */
const onlineRootRef = ref(db, 'online');

function setPresence(h,ch){
  if(!uid) return;
  try {
    if(presenceRef) remove(presenceRef).catch(()=>{});
    presenceRef = ref(db, `online/${ch}/${uid}`);
    set(presenceRef,{name:h,ts:Date.now(),channel:ch,uid, typing:false})
      .then(()=>{
        onDisconnect(presenceRef).remove().catch(()=>{});
      })
      .catch(e => {
        console.error('Presence error (set): ' + e.message, {h,ch,uid});
      });
  } catch(e){
    console.error('Presence failed: ' + e.message, {e});
  }
}

function watchOnline(){
  onValue(onlineRootRef, snap => {
    const data = snap.val() || {};
    renderActiveUsers(data[currentChannel] || {});
    updateUserCount(data);
    updateTypingIndicator(data[currentChannel] || {});
  });
}

function renderActiveUsers(obj){
  activeUsersList.innerHTML = '';
  Object.values(obj || {}).filter(u => u && u.name).forEach(u => {
    const row = document.createElement('div'); row.className = 'user-row';
    const dot = document.createElement('div'); dot.className = 'status-dot';
    const name = document.createElement('div'); name.className = 'uname'; name.textContent = u.name;
    row.append(dot, name);
    activeUsersList.appendChild(row);
  });
}

function updateUserCount(data){
  const count = Object.keys(data[currentChannel] || {}).length;
  userCountSmall.textContent = count + (count === 1 ? ' user' : ' users');
  chatTitle.innerHTML = `//${currentChannel.toUpperCase()} <span class="small">${count} user${count === 1 ? '' : 's'}</span>`;
}

function updateTypingIndicator(obj){
  const typing = Object.values(obj || {}).filter(u => u.typing && u.uid !== uid && u.name).map(u => u.name);
  typingIndicator.textContent = typing.length > 0 ? `${typing.join(', ')} ${typing.length > 1 ? 'are' : 'is'} typing...` : '';
}

/* ---------- Channel & Chat listeners ---------- */
function watchPresenceEvents(){
  const channels = ['sam','exuro','nero','nora','loktal'];
  channels.forEach(ch => {
    onChildAdded(ref(db, `online/${ch}`), snap => {
      const u = snap.val();
      if (u && u.uid !== uid && u.name) console.log(`User '${u.name}' joined //${ch.toUpperCase()}`);
    });
    onChildRemoved(ref(db, `online/${ch}`), snap => {
      const u = snap.val();
      if (u && u.name) console.log(`User '${u.name}' left //${ch.toUpperCase()}`);
    });
  });
}

function listenChannel(ch){
  // remove previous listener if exists
  if(channelListeners[currentChannel]){
    const listener = channelListeners[currentChannel];
    if(listener.ref) off(listener.ref, 'child_added', listener.fn);
  }
  channelListeners = {};
  currentChannel = ch;
  chatMessages.innerHTML = '';
  const r = ref(db, `chat/${ch}`);
  const q = query(r, orderByChild('ts'));
  const fn = snap => {
    const o = snap.val();
    if(o && !o.deleted) renderChatMessage(o, snap.key);
  };
  onChildAdded(q, fn, e => console.error('Chat listen error: ' + (e && e.message)));
  channelListeners[ch] = {ref: r, fn};
}

/* ---------- Render messages ---------- */
function renderChatMessage(o, key){
  if (!o || !o.name) return;
  const row = document.createElement('div'); row.className = 'chat-row';
  const av = document.createElement('div'); av.className = 'chat-avatar'; av.textContent = (o.name || '').slice(0,2).toUpperCase();
  const bub = document.createElement('div'); bub.className = 'chat-bubble';
  if(o.uid === uid) bub.classList.add('me');
  bub.innerHTML = `<div class="chat-meta">${esc(o.name)} · ${new Date(o.ts).toLocaleTimeString()}</div><div>${esc(o.msg)}</div>`;
  if(o.uid === uid){
    const edit = document.createElement('span'); edit.textContent = ' [Edit]'; edit.style.cursor = 'pointer';
    edit.onclick = () => { /* optional edit UI hook */ };
    const del = document.createElement('span'); del.textContent = ' [Delete]'; del.style.cursor = 'pointer';
    del.onclick = () => {
      update(ref(db, `chat/${currentChannel}/${key}`), {deleted: true}).catch(e => console.error('Delete failed: ' + (e && e.message)));
      row.style.display = 'none';
    };
    bub.append(edit, del);
  }
  row.append(av, bub);
  chatMessages.appendChild(row);
  // Auto-scroll with small debounce
  setTimeout(() => { chatMessages.scrollTop = chatMessages.scrollHeight; }, 30);
}

/* ---------- Posting messages (renamed) ---------- */
async function postChatMessage(ch, name, msg){
  if(!uid || !name) {
    console.warn('postChatMessage blocked: missing uid or name', {uid, name});
    return;
  }
  const m = msg.trim();
  if(!m || m.length > 500) return;
  const ts = Date.now();
  const h = await hash(`${ch}|${name}|${m}|${uid}|${Math.floor(ts/1000)}`);
  const key = push(ref(db, `chat/${ch}`)).key;
  const updates = {};
  updates[`/chat/${ch}/${key}`] = {name, msg: m, ts, uid, hash: h};
  updates[`/msgHashes/${h}`] = {channel: ch, key, ts, uid};
  await update(ref(db), updates).catch(e => console.error('Chat post error: ' + (e && e.message)));
  set(ref(db, `online/${ch}/${uid}/ts`), Date.now()).catch(()=>{});
}

/* ---------- Input handlers ---------- */
sendBtn.onclick = () => {
  const val = chatInput.value.trim();
  if(!val) return;
  if(val.startsWith('/d6')){
    const roll = Math.floor(Math.random() * 6) + 1;
    postChatMessage(currentChannel, myHandle, `rolled d6: ${roll}`);
  } else if(val.startsWith('/d20')){
    const roll = Math.floor(Math.random() * 20) + 1;
    postChatMessage(currentChannel, myHandle, `rolled d20: ${roll}`);
  } else {
    postChatMessage(currentChannel, myHandle, val);
  }
  chatInput.value = '';
  try { set(ref(db, `online/${currentChannel}/${uid}/typing`), false); } catch(e){}
};

chatInput.addEventListener('keydown', e => {
  if(e.key === 'Enter' && !e.shiftKey){ e.preventDefault(); sendBtn.click(); }
});

chatInput.addEventListener('input', () => {
  if(!uid) return;
  try {
    const isTyping = chatInput.value.trim().length > 0;
    set(ref(db, `online/${currentChannel}/${uid}/typing`), isTyping);
  } catch(e) { console.warn('typing flag error', e); }
  clearTimeout(typingTimeout);
  typingTimeout = setTimeout(() => { try { set(ref(db, `online/${currentChannel}/${uid}/typing`), false); } catch(e){} }, 2200);
});

/* ---------- Idle and periodic maintenance ---------- */
function resetIdleTimer() {
  clearTimeout(idleTimer);
  idleTimer = setTimeout(() => { console.log('Idle timeout'); }, 600000); // 10 minutes
}
document.addEventListener('mousemove', resetIdleTimer);
document.addEventListener('keydown', resetIdleTimer);
document.addEventListener('touchstart', resetIdleTimer);

setInterval(() => {
  if (uid && currentChannel) {
    set(ref(db, `online/${currentChannel}/${uid}/ts`), Date.now()).catch(()=>{});
  }
}, 300000);

/* Purge chat messages older than 24h (server-side rules are better; this is opportunistic) */
setInterval(async () => {
  try {
    const snap = await get(ref(db,'chat'));
    const data = snap.val()||{};
    for(const ch in data){
      for(const id in data[ch]){
        if(data[ch][id].ts && Date.now() - data[ch][id].ts > 24*60*60*1000){
          await remove(ref(db, `chat/${ch}/${id}`)).catch(()=>{});
        }
      }
    }
  } catch(e){ console.error('Purge error'); }
}, 60*60*1000);

/* ---------- Boot flow: sign in anonymously, set handle, init chat ---------- */
bootBtn.addEventListener('click', async () => {
  const raw = bootInput.value.trim().replace(/[^\w\-]/g,'').slice(0,30);
  if(!raw){
    bootStatus.textContent = "Please enter a handle.";
    return;
  }
  bootStatus.textContent = "Entering network...";
  try {
    // Anonymous sign-in hidden, required for online DB writes/presence
    const credential = await signInAnonymously(auth);
    uid = credential.user.uid;
    myHandle = raw;
    currentChannel = bootChannel.value || 'exuro';

    // Save profile quietly
    set(ref(db, `users/${uid}`), {name: myHandle, uid, firstSeen: Date.now()}).catch(()=>{});
    // Optional analytics counters
    const logRef = push(ref(db, 'visitors/logs'));
    set(logRef, {ts: Date.now(), handle: myHandle}).catch(()=>{});

    bootStatus.textContent = `Welcome, ${myHandle}! Initializing chat...`;
    // short delay for UX
    setTimeout(() => {
      bootOverlay.style.display = 'none';
      initChat();
      // Broadcast bootComplete to parent frame (if embedded)
      try {
        window.parent.postMessage({type:'bootComplete', handle: myHandle, channel: currentChannel, uid}, '*');
      } catch(e){}
    }, 600);
  } catch(e){
    console.error('Authentication failed: ' + (e && e.message));
    bootStatus.textContent = "Failed to enter network: " + (e && e.message);
  }
});

/* ---------- Initialize chat only when both uid & myHandle are set ---------- */
function initChat(){
  if(!uid || !myHandle){
    console.log('initChat waiting for uid/myHandle', {uid, myHandle});
    return;
  }
  try {
    setPresence(myHandle, currentChannel);
    listenChannel(currentChannel);
    watchOnline();
    watchPresenceEvents();
    resetIdleTimer();
    // keep a watch to update presence if channel changes from UI (not shown) - expose channel switch via console if needed
    console.log(`Chat initialized as ${myHandle} in //${currentChannel}`);
  } catch(e){
    console.error('initChat error', e);
  }
}

/* ---------- Clean up on unload ---------- */
window.addEventListener('beforeunload', () => {
  try { if(presenceRef) remove(presenceRef); } catch(e){}
});

/* expose a quick channel switch helper (dev convenience) */
window.BUU = {
  switchChannel: function(newCh){
    if(!newCh) return;
    if(newCh === currentChannel) return;
    // confirm style transition
    document.body.style.opacity = 0.25;
    setTimeout(() => {
      listenChannel(newCh);
      setPresence(myHandle, newCh);
      currentChannel = newCh;
      document.body.style.opacity = 1;
    }, 450);
  }
};
</script>
</body>
</html>
