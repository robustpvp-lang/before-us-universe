<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Space Tunnel Shooter</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-user-select: none;
            user-select: none;
        }
        body {
            background: #000;
            overflow: hidden;
            font-family: monospace;
            touch-action: none;
        }
        #game {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        .btn {
            position: fixed;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: 3px solid;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            pointer-events: all;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        #fire {
            bottom: 20px;
            left: 20px;
            background: rgba(255, 50, 50, 0.5);
            border-color: #ff3333;
        }
        #fire:active {
            background: rgba(255, 50, 50, 0.9);
            transform: scale(0.9);
        }
        #weapon {
            bottom: 120px;
            left: 20px;
            background: rgba(255, 165, 0, 0.5);
            border-color: #ffa500;
            font-size: 28px;
        }
        #weapon:active {
            background: rgba(255, 165, 0, 0.9);
            transform: scale(0.9);
        }
        .joystick {
            position: fixed;
            width: 140px;
            height: 140px;
            pointer-events: all;
        }
        #moveJoy {
            bottom: 30px;
            left: 130px;
        }
        #lookJoy {
            bottom: 30px;
            right: 30px;
        }
        .joy-base {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: rgba(100, 100, 100, 0.3);
            border: 2px solid rgba(150, 150, 150, 0.5);
            position: relative;
        }
        .joy-stick {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(0, 255, 0, 0.5);
            border: 2px solid #0f0;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        #fps {
            position: fixed;
            top: 10px;
            left: 10px;
            color: #0f0;
            background: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 14px;
            pointer-events: none;
        }
        #weaponDisplay {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #0f0;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 18px;
            pointer-events: none;
        }
        #bossHealth {
            position: fixed;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 400px;
            pointer-events: none;
        }
        #bossName {
            color: #ff0000;
            text-align: center;
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 5px;
            text-shadow: 0 0 10px #ff0000;
        }
        #healthBarBg {
            width: 100%;
            height: 30px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #ff0000;
            border-radius: 5px;
            overflow: hidden;
        }
        #healthBarFill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ff6600);
            width: 100%;
            transition: width 0.3s;
        }
        #playerHealth {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 60%;
            max-width: 300px;
            pointer-events: none;
        }
        #playerHealthBg {
            width: 100%;
            height: 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #00ff00;
            border-radius: 5px;
            overflow: hidden;
        }
        #playerHealthFill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #00aa00);
            width: 100%;
            transition: width 0.3s;
        }
        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }
        .crosshair-line {
            position: absolute;
            background: rgba(0, 255, 0, 0.6);
        }
        .h-line {
            width: 30px;
            height: 2px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        .v-line {
            width: 2px;
            height: 30px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        #titleScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(180deg, #000033 0%, #000000 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }
        #titleScreen.hidden {
            display: none;
        }
        #gameTitle {
            font-size: 48px;
            color: #ff00ff;
            text-shadow: 0 0 20px #ff00ff, 0 0 40px #ff00ff;
            margin-bottom: 20px;
            text-align: center;
            padding: 0 20px;
        }
        #gameSubtitle {
            font-size: 20px;
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
            margin-bottom: 40px;
            text-align: center;
        }
        #startButton {
            padding: 20px 60px;
            font-size: 28px;
            background: linear-gradient(90deg, #ff00ff, #00ffff);
            border: 3px solid #fff;
            border-radius: 10px;
            color: #fff;
            font-weight: bold;
            cursor: pointer;
            text-shadow: 0 0 10px #000;
            box-shadow: 0 0 30px rgba(255, 0, 255, 0.5);
            font-family: monospace;
        }
        #startButton:active {
            transform: scale(0.95);
        }
        #credits {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #888;
            font-size: 14px;
            text-align: center;
        }
        #resetButton {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 10px 20px;
            font-size: 16px;
            background: rgba(255, 0, 0, 0.5);
            border: 2px solid #ff0000;
            border-radius: 5px;
            color: #fff;
            font-weight: bold;
            cursor: pointer;
            font-family: monospace;
            pointer-events: all;
            z-index: 100;
        }
        #resetButton:active {
            background: rgba(255, 0, 0, 0.9);
            transform: scale(0.95);
        }
    </style>
</head>
<body>
    <canvas id="game"></canvas>
    
    <div id="titleScreen">
        <h1 id="gameTitle">COSMIC HORROR<br>TUNNEL SHOOTER</h1>
        <p id="gameSubtitle">Defeat the Ancient Evil</p>
        <button id="startButton">START GAME</button>
        <div id="credits">Created by Patrick McDonald and Claude</div>
    </div>
    
    <div id="fps">FPS: 60</div>
    <div id="weaponDisplay">BULLETS</div>
    <button id="resetButton">RESET</button>
    <div id="bossHealth">
        <div id="bossName">COSMIC HORROR</div>
        <div id="healthBarBg">
            <div id="healthBarFill"></div>
        </div>
    </div>
    <div id="playerHealth">
        <div id="playerHealthBg">
            <div id="playerHealthFill"></div>
        </div>
    </div>
    <div id="crosshair">
        <div class="crosshair-line h-line"></div>
        <div class="crosshair-line v-line"></div>
    </div>
    
    <div class="joystick" id="moveJoy">
        <div class="joy-base">
            <div class="joy-stick" id="moveStick"></div>
        </div>
    </div>
    
    <div class="joystick" id="lookJoy">
        <div class="joy-base">
            <div class="joy-stick" id="lookStick"></div>
        </div>
    </div>
    
    <div class="btn" id="fire">üî•</div>
    <div class="btn" id="weapon">‚öîÔ∏è</div>

    <script>
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        
        let gameStarted = false;
        
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener('resize', resize);
        
        // Start button
        document.getElementById('startButton').addEventListener('click', () => {
            document.getElementById('titleScreen').classList.add('hidden');
            gameStarted = true;
        });
        
        // Reset button
        document.getElementById('resetButton').addEventListener('click', () => {
            location.reload();
        });
        
        const player = {
            x: 0, y: 0, z: 0,
            pitch: 0, yaw: 0,
            speed: 0.3,
            boostSpeed: 1.5,
            weapon: 0,
            firing: false,
            boosting: false,
            health: 100,
            maxHealth: 100
        };
        
        const boss = {
            x: 0, y: 100, z: 800,
            health: 100,
            maxHealth: 100,
            size: 250,
            tentacles: [],
            eyeAngle: 0,
            beakOpen: 0,
            defeated: false,
            deathTimer: 0
        };
        
        // Initialize boss tentacles
        for (let i = 0; i < 8; i++) {
            boss.tentacles.push({
                angle: (Math.PI * 2 / 8) * i,
                length: 150,
                segments: 8,
                wave: Math.random() * Math.PI * 2
            });
        }
        
        const weapons = ['BULLETS', 'MACHINE GUN'];
        const tunnelRadius = 150;
        
        // Projectiles and drones
        const projectiles = [];
        const drones = [];
        let droneSpawnTimer = 0;
        
        // Tunnel stars
        const stars = [];
        for (let i = 0; i < 300; i++) {
            const angle = Math.random() * Math.PI * 2;
            const radius = tunnelRadius + (Math.random() - 0.5) * 20;
            stars.push({
                x: Math.cos(angle) * radius,
                y: Math.sin(angle) * radius,
                z: Math.random() * 2000 - 1000,
                size: Math.random() * 2 + 1
            });
        }
        
        // Planet
        const planet = { x: 0, y: 150, z: 900, radius: 120 };
        
        // Joysticks
        const joy = {
            move: { x: 0, y: 0, active: false, id: null },
            look: { x: 0, y: 0, active: false, id: null }
        };
        
        function handleJoy(el, j, touch) {
            const rect = el.getBoundingClientRect();
            const cx = rect.left + rect.width / 2;
            const cy = rect.top + rect.height / 2;
            let dx = touch.clientX - cx;
            let dy = touch.clientY - cy;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const max = rect.width / 2;
            if (dist > max) {
                dx = dx / dist * max;
                dy = dy / dist * max;
            }
            j.x = dx / max;
            j.y = dy / max;
            const stick = el.querySelector('.joy-stick');
            stick.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
        }
        
        function resetJoy(el, j) {
            j.x = 0; j.y = 0; j.active = false; j.id = null;
            el.querySelector('.joy-stick').style.transform = 'translate(-50%, -50%)';
        }
        
        const moveEl = document.getElementById('moveJoy');
        const lookEl = document.getElementById('lookJoy');
        
        document.addEventListener('touchstart', e => {
            for (let t of e.touches) {
                const el = document.elementFromPoint(t.clientX, t.clientY);
                if (moveEl.contains(el) && !joy.move.active) {
                    joy.move.active = true;
                    joy.move.id = t.identifier;
                    handleJoy(moveEl, joy.move, t);
                } else if (lookEl.contains(el) && !joy.look.active) {
                    joy.look.active = true;
                    joy.look.id = t.identifier;
                    handleJoy(lookEl, joy.look, t);
                }
            }
        });
        
        document.addEventListener('touchmove', e => {
            e.preventDefault();
            for (let t of e.touches) {
                if (joy.move.active && t.identifier === joy.move.id) {
                    handleJoy(moveEl, joy.move, t);
                } else if (joy.look.active && t.identifier === joy.look.id) {
                    handleJoy(lookEl, joy.look, t);
                }
            }
        }, { passive: false });
        
        document.addEventListener('touchend', e => {
            for (let t of e.changedTouches) {
                if (joy.move.id === t.identifier) resetJoy(moveEl, joy.move);
                if (joy.look.id === t.identifier) resetJoy(lookEl, joy.look);
            }
        });
        
        // Fire button
        const fireBtn = document.getElementById('fire');
        let canFire = true;
        
        function shoot() {
            if (!canFire) return;
            
            projectiles.push({
                x: player.x,
                y: player.y,
                z: player.z,
                vx: Math.sin(player.yaw) * Math.cos(player.pitch) * 4,
                vy: Math.sin(player.pitch) * 4,
                vz: Math.cos(player.yaw) * Math.cos(player.pitch) * 4,
                type: 'bullet',
                life: 150
            });
            
            const fireRate = player.weapon === 1 ? 80 : 150;
            canFire = false;
            setTimeout(() => { canFire = true; }, fireRate);
        }
        
        fireBtn.addEventListener('touchstart', e => {
            e.preventDefault();
            player.firing = true;
            shoot();
        });
        
        fireBtn.addEventListener('touchend', e => {
            e.preventDefault();
            player.firing = false;
        });
        
        fireBtn.addEventListener('click', e => {
            e.preventDefault();
            player.firing = true;
            shoot();
            setTimeout(() => { player.firing = false; }, 100);
        });
        
        // Weapon button
        const weaponBtn = document.getElementById('weapon');
        const weaponDisplay = document.getElementById('weaponDisplay');
        
        weaponBtn.addEventListener('touchstart', e => {
            e.preventDefault();
            player.weapon = (player.weapon + 1) % weapons.length;
            weaponDisplay.textContent = weapons[player.weapon];
        });
        
        weaponBtn.addEventListener('click', e => {
            e.preventDefault();
            player.weapon = (player.weapon + 1) % weapons.length;
            weaponDisplay.textContent = weapons[player.weapon];
        });
        
        // Update
        function update() {
            const spd = player.boosting ? player.boostSpeed : player.speed;
            
            player.z += spd;
            player.boosting = joy.move.active;
            
            if (joy.look.active) {
                player.yaw += joy.look.x * 0.03;
                player.pitch -= joy.look.y * 0.03;
                player.pitch = Math.max(-Math.PI/3, Math.min(Math.PI/3, player.pitch));
            }
            
            // Spawn drones
            if (!boss.defeated && boss.health > 0) {
                droneSpawnTimer++;
                if (droneSpawnTimer > 120 && drones.length < 5) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 100;
                    drones.push({
                        x: boss.x + Math.cos(angle) * distance,
                        y: boss.y + Math.sin(angle) * distance,
                        z: boss.z - 50,
                        vx: 0, vy: 0, vz: 0,
                        health: 2,
                        size: 15
                    });
                    droneSpawnTimer = 0;
                }
            }
            
            // Update drones
            for (let i = drones.length - 1; i >= 0; i--) {
                const d = drones[i];
                const dx = player.x - d.x;
                const dy = player.y - d.y;
                const dz = player.z - d.z;
                const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                
                const speed = 0.15;
                d.vx = (dx / dist) * speed;
                d.vy = (dy / dist) * speed;
                d.vz = (dz / dist) * speed;
                
                d.x += d.vx;
                d.y += d.vy;
                d.z += d.vz;
                
                if (dist < 20) {
                    player.health = Math.max(0, player.health - 10);
                    drones.splice(i, 1);
                    continue;
                }
                
                if (d.z < player.z - 500) {
                    drones.splice(i, 1);
                }
            }
            
            // Update projectiles
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.z += p.vz;
                p.life--;
                
                let projectileRemoved = false;
                
                // Check drone collision
                for (let j = drones.length - 1; j >= 0; j--) {
                    const d = drones[j];
                    const dx = p.x - d.x;
                    const dy = p.y - d.y;
                    const dz = p.z - d.z;
                    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    
                    if (dist < d.size) {
                        d.health--;
                        if (d.health <= 0) {
                            drones.splice(j, 1);
                        }
                        projectiles.splice(i, 1);
                        projectileRemoved = true;
                        break;
                    }
                }
                
                if (projectileRemoved) continue;
                
                // Check boss collision
                const dx = p.x - boss.x;
                const dy = p.y - boss.y;
                const dz = p.z - boss.z;
                const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                
                if (dist < boss.size && boss.health > 0) {
                    boss.health = Math.max(0, boss.health - 0.5);
                    projectiles.splice(i, 1);
                    continue;
                }
                
                if (p.life <= 0) {
                    projectiles.splice(i, 1);
                }
            }
            
            // Continuous fire for machine gun
            if (player.firing && canFire) {
                shoot();
            }
            
            // Update boss
            if (boss.health <= 0 && !boss.defeated) {
                boss.defeated = true;
                boss.deathTimer = 0;
            }
            
            if (boss.defeated) {
                boss.deathTimer++;
                boss.y -= 0.5;
                boss.z += 0.3;
            } else {
                boss.eyeAngle += 0.02;
                boss.beakOpen = Math.sin(Date.now() * 0.003) * 0.3 + 0.5;
                for (let t of boss.tentacles) {
                    t.wave += 0.05;
                }
            }
            
            // Update health bars
            document.getElementById('healthBarFill').style.width = (boss.health / boss.maxHealth * 100) + '%';
            document.getElementById('playerHealthFill').style.width = (player.health / player.maxHealth * 100) + '%';
            
            // Wrap stars
            for (let star of stars) {
                if (star.z < player.z - 500) {
                    star.z += 1500;
                }
            }
        }
        
        // Render
        function render() {
            const W = canvas.width;
            const H = canvas.height;
            
            // Space background
            const grad = ctx.createRadialGradient(W/2, H/2, 0, W/2, H/2, Math.max(W, H));
            grad.addColorStop(0, '#001133');
            grad.addColorStop(1, '#000000');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, W, H);
            
            // Draw tunnel stars
            ctx.fillStyle = '#fff';
            for (let star of stars) {
                const dx = star.x - player.x;
                const dy = star.y - player.y;
                const dz = star.z - player.z;
                
                const rx = dx * Math.cos(player.yaw) - dz * Math.sin(player.yaw);
                const rz = dx * Math.sin(player.yaw) + dz * Math.cos(player.yaw);
                const ry = dy * Math.cos(player.pitch) - rz * Math.sin(player.pitch);
                const rz2 = dy * Math.sin(player.pitch) + rz * Math.cos(player.pitch);
                
                if (rz2 > 0) {
                    const scale = 300 / rz2;
                    const sx = W/2 + rx * scale;
                    const sy = H/2 - ry * scale;
                    const size = star.size * scale;
                    
                    if (sx >= 0 && sx < W && sy >= 0 && sy < H) {
                        ctx.fillRect(sx, sy, size, size);
                    }
                }
            }
            
            // Draw planet FIRST
            let pdx = planet.x - player.x;
            let pdy = planet.y - player.y;
            let pdz = planet.z - player.z;
            
            let prx = pdx * Math.cos(player.yaw) - pdz * Math.sin(player.yaw);
            let prz = pdx * Math.sin(player.yaw) + pdz * Math.cos(player.yaw);
            let pry = pdy * Math.cos(player.pitch) - prz * Math.sin(player.pitch);
            let prz2 = pdy * Math.sin(player.pitch) + prz * Math.cos(player.pitch);
            
            if (prz2 > 0) {
                const scale = 300 / prz2;
                const px = W/2 + prx * scale;
                const py = H/2 - pry * scale;
                const radius = planet.radius * scale;
                
                const pgrad = ctx.createRadialGradient(px - radius/3, py - radius/3, 0, px, py, radius);
                pgrad.addColorStop(0, '#4488ff');
                pgrad.addColorStop(0.5, '#2266dd');
                pgrad.addColorStop(1, '#1144aa');
                ctx.fillStyle = pgrad;
                ctx.beginPath();
                ctx.arc(px, py, radius, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = 'rgba(100, 150, 255, 0.2)';
                ctx.beginPath();
                ctx.arc(px, py, radius * 1.3, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Draw boss
            let bdx = boss.x - player.x;
            let bdy = boss.y - player.y;
            let bdz = boss.z - player.z;
            
            let brx = bdx * Math.cos(player.yaw) - bdz * Math.sin(player.yaw);
            let brz = bdx * Math.sin(player.yaw) + bdz * Math.cos(player.yaw);
            let bry = bdy * Math.cos(player.pitch) - brz * Math.sin(player.pitch);
            let brz2 = bdy * Math.sin(player.pitch) + brz * Math.cos(player.pitch);
            
            if (brz2 > 0 && boss.deathTimer < 200) {
                const scale = 300 / brz2;
                const bx = W/2 + brx * scale;
                const by = H/2 - bry * scale;
                const bsize = boss.size * scale;
                const opacity = boss.defeated ? Math.max(0, 1 - boss.deathTimer / 200) : 1;
                
                // Draw tentacles
                for (let t of boss.tentacles) {
                    ctx.strokeStyle = 'rgba(102, 0, 102, ' + opacity + ')';
                    ctx.lineWidth = 12 * scale;
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#660066';
                    
                    ctx.beginPath();
                    let lastX = bx + Math.cos(t.angle) * bsize * 0.4;
                    let lastY = by + Math.sin(t.angle) * bsize * 0.4;
                    ctx.moveTo(lastX, lastY);
                    
                    const droop = boss.defeated ? boss.deathTimer * 0.5 : 0;
                    
                    for (let s = 1; s <= t.segments; s++) {
                        const segDist = (t.length / t.segments) * s * scale;
                        const wave = Math.sin(t.wave + s * 0.5) * 25 * scale;
                        const nx = lastX + Math.cos(t.angle) * segDist/t.segments + wave * Math.cos(t.angle + Math.PI/2);
                        const ny = lastY + Math.sin(t.angle) * segDist/t.segments + wave * Math.sin(t.angle + Math.PI/2) + droop;
                        ctx.lineTo(nx, ny);
                        lastX = nx;
                        lastY = ny;
                    }
                    ctx.stroke();
                    
                    ctx.fillStyle = 'rgba(153, 0, 153, ' + opacity + ')';
                    for (let s = 2; s < t.segments; s += 2) {
                        const segDist = (t.length / t.segments) * s * scale;
                        const wave = Math.sin(t.wave + s * 0.5) * 25 * scale;
                        const sx = bx + Math.cos(t.angle) * (bsize * 0.4 + segDist) + wave * Math.cos(t.angle + Math.PI/2);
                        const sy = by + Math.sin(t.angle) * (bsize * 0.4 + segDist) + wave * Math.sin(t.angle + Math.PI/2) + droop * (s/t.segments);
                        ctx.beginPath();
                        ctx.arc(sx, sy, 5 * scale, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                ctx.shadowBlur = 0;
                
                // Main body
                const bodyGrad = ctx.createRadialGradient(bx, by - bsize * 0.2, 0, bx, by, bsize);
                bodyGrad.addColorStop(0, 'rgba(170, 0, 170, ' + opacity + ')');
                bodyGrad.addColorStop(0.5, 'rgba(102, 0, 102, ' + opacity + ')');
                bodyGrad.addColorStop(1, 'rgba(51, 0, 51, ' + opacity + ')');
                ctx.fillStyle = bodyGrad;
                ctx.beginPath();
                ctx.arc(bx, by, bsize, 0, Math.PI * 2);
                ctx.fill();
                
                // Evil eye slits
                const eyePositions = [[-0.35, -0.25], [0.35, -0.25], [0, -0.45]];
                
                for (let pos of eyePositions) {
                    const eyeX = bx + pos[0] * bsize;
                    const eyeY = by + pos[1] * bsize;
                    
                    ctx.fillStyle = 'rgba(255, 0, 0, ' + opacity + ')';
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#ff0000';
                    ctx.save();
                    ctx.translate(eyeX, eyeY);
                    ctx.rotate(Math.sin(boss.eyeAngle + pos[0] * 2) * 0.3);
                    ctx.fillRect(-bsize * 0.15, -bsize * 0.03, bsize * 0.3, bsize * 0.06);
                    ctx.restore();
                    ctx.shadowBlur = 0;
                }
                
                // Beak
                const beakY = by + bsize * 0.2;
                const beakSize = bsize * 0.5;
                const beakGap = boss.beakOpen * beakSize * 0.4;
                
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#000';
                
                ctx.fillStyle = 'rgba(40, 40, 40, ' + opacity + ')';
                ctx.beginPath();
                ctx.moveTo(bx, beakY - beakGap);
                ctx.lineTo(bx - beakSize * 0.4, beakY - beakSize * 0.3 - beakGap);
                ctx.lineTo(bx, beakY - beakSize * 0.6 - beakGap);
                ctx.lineTo(bx + beakSize * 0.4, beakY - beakSize * 0.3 - beakGap);
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = 'rgba(20, 20, 20, ' + opacity + ')';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                ctx.fillStyle = 'rgba(30, 30, 30, ' + opacity + ')';
                ctx.beginPath();
                ctx.moveTo(bx, beakY + beakGap);
                ctx.lineTo(bx - beakSize * 0.4, beakY + beakSize * 0.3 + beakGap);
                ctx.lineTo(bx, beakY + beakSize * 0.6 + beakGap);
                ctx.lineTo(bx + beakSize * 0.4, beakY + beakSize * 0.3 + beakGap);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                if (boss.beakOpen > 0.3) {
                    ctx.fillStyle = 'rgba(0, 0, 0, ' + (opacity * 0.9) + ')';
                    ctx.beginPath();
                    ctx.ellipse(bx, beakY, beakSize * 0.3, beakGap * 0.8, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.shadowBlur = 0;
                
                if (!boss.defeated) {
                    ctx.strokeStyle = 'rgba(139, 0, 139, 0.4)';
                    ctx.lineWidth = 15 * scale;
                    ctx.shadowBlur = 30;
                    ctx.shadowColor = '#aa00aa';
                    ctx.beginPath();
                    ctx.arc(bx, by, bsize * 1.3, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }
            }
            
            // Draw drones
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#ff0000';
            for (let drone of drones) {
                const dx = drone.x - player.x;
                const dy = drone.y - player.y;
                const dz = drone.z - player.z;
                
                const rx = dx * Math.cos(player.yaw) - dz * Math.sin(player.yaw);
                const rz = dx * Math.sin(player.yaw) + dz * Math.cos(player.yaw);
                const ry = dy * Math.cos(player.pitch) - rz * Math.sin(player.pitch);
                const rz2 = dy * Math.sin(player.pitch) + rz * Math.cos(player.pitch);
                
                if (rz2 > 0) {
                    const scale = 300 / rz2;
                    const droneX = W/2 + rx * scale;
                    const droneY = H/2 - ry * scale;
                    const droneSize = drone.size * scale;
                    
                    ctx.fillStyle = '#990099';
                    ctx.beginPath();
                    ctx.arc(droneX, droneY, droneSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.strokeStyle = '#660066';
                    ctx.lineWidth = 2 * scale;
                    for (let i = 0; i < 4; i++) {
                        const angle = (i / 4) * Math.PI * 2 + Date.now() * 0.001;
                        ctx.beginPath();
                        ctx.moveTo(droneX, droneY);
                        ctx.lineTo(
                            droneX + Math.cos(angle) * droneSize * 1.5,
                            droneY + Math.sin(angle) * droneSize * 1.5
                        );
                        ctx.stroke();
                    }
                    
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.arc(droneX, droneY, droneSize * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            ctx.shadowBlur = 0;
            
            // Draw projectiles
            for (let proj of projectiles) {
                const dx = proj.x - player.x;
                const dy = proj.y - player.y;
                const dz = proj.z - player.z;
                
                const rx = dx * Math.cos(player.yaw) - dz * Math.sin(player.yaw);
                const rz = dx * Math.sin(player.yaw) + dz * Math.cos(player.yaw);
                const ry = dy * Math.cos(player.pitch) - rz * Math.sin(player.pitch);
                const rz2 = dy * Math.sin(player.pitch) + rz * Math.cos(player.pitch);
                
                if (rz2 > 0) {
                    const scale = 300 / rz2;
                    const sx = W/2 + rx * scale;
                    const sy = H/2 - ry * scale;
                    
                    ctx.fillStyle = '#ffff00';
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = '#ffff00';
                    const size = 1.5 * scale;
                    ctx.fillRect(sx - size/2, sy - size/2, size, size);
                    ctx.shadowBlur = 0;
                }
            }
            
            // Muzzle flash
            if (player.firing) {
                const alpha = player.weapon === 0 ? 0.3 : 0.5;
                ctx.fillStyle = 'rgba(255, 255, 0, ' + alpha + ')';
                const flashSize = 100;
                ctx.fillRect(W/2 - flashSize/2, H/2 - flashSize/2, flashSize, flashSize);
            }
        }
        
        // Game loop
        let lastTime = performance.now();
        let frames = 0;
        
        function loop() {
            if (gameStarted) {
                update();
                render();
            }
            
            frames++;
            const now = performance.now();
            if (now >= lastTime + 1000) {
                document.getElementById('fps').textContent = 'FPS: ' + Math.round(frames * 1000 / (now - lastTime));
                frames = 0;
                lastTime = now;
            }
            
            requestAnimationFrame(loop);
        }
        
        loop();
    </script>
</body>
</html>
